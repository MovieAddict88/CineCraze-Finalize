<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <meta name="theme-color" content="#e50914">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Playlist Categories Manager</title>
    <style>
        :root {
            --primary: #e50914;
            --primary-dark: #b8070f;
            --secondary: #221f1f;
            --background: #141414;
            --surface: #1f1f1f;
            --surface-light: #2a2a2a;
            --text: #ffffff;
            --text-secondary: #b3b3b3;
            --success: #46d369;
            --warning: #ffa500;
            --danger: #f40612;
            --accent: #00d4ff;
            --bottom-bar-height: 80px;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, var(--background) 0%, var(--secondary) 100%);
            color: var(--text);
            min-height: 100vh;
            padding: max(20px, env(safe-area-inset-top)) max(20px, env(safe-area-inset-right)) calc(var(--bottom-bar-height) + max(20px, env(safe-area-inset-bottom))) max(20px, env(safe-area-inset-left));
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            margin-bottom: 40px;
            padding: 30px;
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(229, 9, 20, 0.3);
        }
        
        h1 {
            font-size: clamp(1.8rem, 4vw, 3rem);
            margin-bottom: 15px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        
        .subtitle {
            font-size: clamp(1rem, 2.5vw, 1.3rem);
            opacity: 0.9;
            font-weight: 300;
        }
        
        /* Bottom Navigation Bar */
        .bottom-nav {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(135deg, var(--surface) 0%, var(--surface-light) 100%);
            border-top: 2px solid var(--primary);
            box-shadow: 0 -8px 32px rgba(0,0,0,0.4);
            backdrop-filter: blur(20px);
            z-index: 1000;
            height: var(--bottom-bar-height);
            -webkit-backdrop-filter: blur(20px); /* Safari support */
        }
        
        .nav-container {
            display: flex;
            justify-content: space-around;
            align-items: center;
            height: 100%;
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 max(10px, env(safe-area-inset-left)) 0 max(10px, env(safe-area-inset-right));
        }
        
        .nav-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 12px;
            transition: all 0.3s ease;
            min-width: 60px;
            text-decoration: none;
            color: var(--text-secondary);
        }
        
        .nav-item:hover {
            background: rgba(229, 9, 20, 0.1);
            color: var(--text);
            transform: translateY(-2px);
        }
        
        .nav-item:active {
            transform: translateY(0);
            transition: transform 0.1s ease;
        }
        
        .nav-item.active {
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(229, 9, 20, 0.4);
        }
        
        .nav-item:focus {
            outline: 2px solid var(--accent);
            outline-offset: 2px;
        }
        
        .nav-item:focus:not(:focus-visible) {
            outline: none;
        }
        
        .nav-icon {
            font-size: clamp(1.2rem, 3vw, 1.5rem);
            margin-bottom: 4px;
        }
        
        .nav-label {
            font-size: clamp(0.7rem, 2vw, 0.8rem);
            font-weight: 600;
            text-align: center;
            line-height: 1;
        }
        
        .card {
            background: var(--surface);
            border-radius: 15px;
            padding: clamp(20px, 4vw, 30px);
            margin-bottom: 30px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            border: 1px solid var(--surface-light);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        
        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 12px 48px rgba(0,0,0,0.4);
        }
        
        .card h2 {
            color: var(--primary);
            margin-bottom: 25px;
            font-size: clamp(1.3rem, 3vw, 1.8rem);
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .card h2::before {
            content: "🎬";
            font-size: 1.5em;
        }
        
        .form-group {
            margin-bottom: 25px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: var(--text-secondary);
            font-size: clamp(0.9rem, 2vw, 1rem);
        }
        
        input, select, textarea {
            width: 100%;
            padding: clamp(12px, 2.5vw, 15px);
            border: 2px solid var(--surface-light);
            border-radius: 10px;
            background: var(--background);
            color: var(--text);
            font-size: clamp(14px, 2.5vw, 16px);
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
        }
        
        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(229, 9, 20, 0.2);
        }
        
        .btn {
            padding: clamp(12px, 2.5vw, 15px) clamp(20px, 4vw, 30px);
            border: none;
            border-radius: 10px;
            font-size: clamp(14px, 2.5vw, 16px);
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 10px;
            margin: 5px;
            text-align: center;
            justify-content: center;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            color: white;
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(229, 9, 20, 0.4);
        }
        
        .btn-secondary {
            background: var(--surface-light);
            color: var(--text);
            border: 2px solid var(--surface-light);
        }
        
        .btn-secondary:hover {
            background: var(--accent);
            border-color: var(--accent);
            color: var(--background);
        }
        
        .btn-success {
            background: var(--success);
            color: white;
        }
        
        .btn-warning {
            background: var(--warning);
            color: white;
        }
        
        .btn-danger {
            background: var(--danger);
            color: white;
        }
        
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(min(300px, 100%), 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .grid-2 {
            grid-template-columns: repeat(auto-fit, minmax(min(400px, 100%), 1fr));
        }

        /* Tab content styling */
        .tab-content {
            display: none;
            animation: fadeIn 0.3s ease-in-out;
        }
        
        .tab-content.active {
            display: block;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .preview-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(min(200px, 100%), 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .preview-item {
            background: var(--surface-light);
            border-radius: 10px;
            overflow: hidden;
            transition: transform 0.3s ease;
        }
        
        .preview-item:hover {
            transform: scale(1.05);
        }
        
        .preview-item img {
            width: 100%;
            height: clamp(200px, 40vw, 300px);
            object-fit: cover;
        }
        
        .preview-item .info {
            padding: 15px;
        }
        
        .preview-item .title {
            font-weight: 600;
            margin-bottom: 5px;
            font-size: clamp(0.9rem, 2vw, 1rem);
        }
        
        .preview-item .meta {
            font-size: clamp(0.8rem, 1.8vw, 0.9rem);
            color: var(--text-secondary);
        }
        
        .progress-bar {
            width: 100%;
            height: 6px;
            background: var(--surface-light);
            border-radius: 3px;
            overflow: hidden;
            margin: 20px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--accent));
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .status {
            padding: 10px 20px;
            border-radius: 8px;
            margin: 10px 0;
            font-weight: 600;
            font-size: clamp(0.9rem, 2vw, 1rem);
        }
        
        .status.success { background: rgba(70, 211, 105, 0.2); color: var(--success); }
        .status.warning { background: rgba(255, 165, 0, 0.2); color: var(--warning); }
        .status.error { background: rgba(244, 6, 18, 0.2); color: var(--danger); }
        .status.info { background: rgba(0, 212, 255, 0.2); color: var(--accent); }
        
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 34px;
        }
        
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--surface-light);
            transition: .4s;
            border-radius: 34px;
        }
        
        .slider:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        
        input:checked + .slider {
            background-color: var(--primary);
        }
        
        input:checked + .slider:before {
            transform: translateX(26px);
        }
        
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.8);
        }
        
        .modal-content {
            background-color: var(--surface);
            margin: 5% auto;
            padding: clamp(20px, 4vw, 30px);
            border-radius: 15px;
            width: min(90%, 800px);
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .close {
            color: var(--text-secondary);
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        
        .close:hover {
            color: var(--primary);
        }
        
        .server-list {
            margin-top: 15px;
        }
        
        .server-item {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .server-item input {
            flex: 1;
            min-width: 200px;
        }
        
        .server-item .paste-btn {
            padding: 8px 12px;
            background: var(--accent);
            color: var(--background);
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
            white-space: nowrap;
        }
        
        .server-item .paste-btn:hover {
            background: var(--primary);
            transform: translateY(-1px);
        }
        
        .btn-small {
            padding: 8px 15px;
            font-size: clamp(12px, 2vw, 14px);
        }
        
        .season-group {
            border: 1px solid var(--surface-light);
            padding: 15px;
            margin: 10px 0;
            border-radius: 8px;
            background: var(--surface);
        }
        
        .episode-group {
            margin: 10px 0;
            padding: 10px;
            background: var(--background);
            border-radius: 5px;
            border-left: 3px solid var(--primary);
        }
        
        .episode-group h5 {
            margin-bottom: 10px;
            color: var(--primary);
        }
        
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid var(--surface-light);
            border-radius: 50%;
            border-top-color: var(--primary);
            animation: spin 1s ease-in-out infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .auto-embed-config {
            background: var(--surface-light);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .embed-option {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
            padding: 10px;
            background: var(--background);
            border-radius: 8px;
            border: 1px solid var(--surface-light);
            flex-wrap: wrap;
        }

        .embed-option:last-child {
            margin-bottom: 0;
        }

        .embed-option input[type="checkbox"] {
            width: auto;
            margin: 0;
        }

        .embed-option label {
            flex: 1;
            margin: 0;
            font-weight: 600;
            color: var(--text);
            min-width: 150px;
        }

        .embed-option select {
            width: auto;
            min-width: 100px;
            padding: 8px 12px;
        }

        .auto-embed-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }

        .auto-embed-actions .btn {
            flex: 1;
            min-width: 150px;
        }

        .tmdb-update-container {
            display: flex;
            gap: 10px;
            align-items: flex-end;
            flex-wrap: wrap;
        }

        .tmdb-input-wrapper {
            flex: 1;
            min-width: 200px;
        }

        .tmdb-update-btn {
            white-space: nowrap;
            flex-shrink: 0;
        }

        #auto-embed-content-select {
            max-height: 200px;
            overflow-y: auto;
        }

        #selected-content-info {
            margin-top: 10px;
            padding: 15px;
            border-radius: 8px;
            background: var(--surface-light);
            border-left: 4px solid var(--accent);
        }

        .checkbox-content-container {
            background: var(--surface-light);
            border-radius: 10px;
            padding: 15px;
            border: 1px solid var(--surface-light);
        }

        .checkbox-header {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .selection-counter {
            font-weight: 600;
            color: var(--accent);
            margin-left: auto;
        }

        .content-checkbox-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid var(--surface-light);
            border-radius: 8px;
            background: var(--background);
        }

        .content-checkbox-item {
            display: flex;
            align-items: center;
            padding: 12px 15px;
            border-bottom: 1px solid var(--surface-light);
            transition: background 0.2s ease;
            position: relative;
        }

        .content-checkbox-item:last-child {
            border-bottom: none;
        }

        .content-checkbox-item:hover {
            background: var(--surface);
        }

        .content-checkbox-item.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .content-checkbox-item input[type="checkbox"] {
            width: auto;
            margin: 0 12px 0 0;
            cursor: pointer;
        }

        .content-checkbox-item.disabled input[type="checkbox"] {
            cursor: not-allowed;
        }

        .content-checkbox-label {
            flex: 1;
            font-weight: 500;
            color: var(--text);
            cursor: pointer;
            line-height: 1.4;
        }

        .content-checkbox-item.disabled .content-checkbox-label {
            cursor: not-allowed;
        }

        .tmdb-status {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.85rem;
            margin-left: auto;
        }

        .tmdb-status.searching {
            color: var(--warning);
        }

        .tmdb-status.found {
            color: var(--success);
        }

        .tmdb-status.not-found {
            color: var(--danger);
        }

        .tmdb-status .loading-spinner {
            display: inline-block;
            width: 12px;
            height: 12px;
            border: 2px solid var(--surface-light);
            border-radius: 50%;
            border-top-color: var(--warning);
            animation: spin 1s ease-in-out infinite;
        }

        .manual-tmdb-input {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 8px;
        }

        .manual-tmdb-input input {
            width: 80px;
            padding: 4px 8px;
            font-size: 0.8rem;
            border: 1px solid var(--surface-light);
            border-radius: 4px;
            background: var(--background);
            color: var(--text);
        }

        .manual-tmdb-input input:focus {
            border-color: var(--accent);
            box-shadow: 0 0 0 2px rgba(0, 212, 255, 0.2);
        }

        .manual-tmdb-input .btn-verify {
            padding: 4px 8px;
            font-size: 0.75rem;
            min-width: auto;
            white-space: nowrap;
        }

        .tmdb-status.not-found {
            flex-direction: column;
            align-items: flex-end;
        }

        .tmdb-status.manual-entry {
            color: var(--accent);
        }

        .bulk-update-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        #bulk-update-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Responsive Design */
        @media (max-width: 1024px) {
            .container {
                padding: 10px;
            }
            
            .grid-2 {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 768px) {
            body {
                padding: max(15px, env(safe-area-inset-top)) max(15px, env(safe-area-inset-right)) calc(var(--bottom-bar-height) + max(15px, env(safe-area-inset-bottom))) max(15px, env(safe-area-inset-left));
            }
            
            .container {
                padding: 0;
            }
            
            header {
                padding: 20px;
                margin-bottom: 30px;
            }
            
            .card {
                padding: 20px;
                margin-bottom: 20px;
            }
            
            .grid {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            .preview-grid {
                grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
                gap: 15px;
            }
            
            .server-item {
                flex-direction: column;
                align-items: stretch;
            }
            
            .server-item input {
                min-width: auto;
                margin-bottom: 5px;
            }
            
            .auto-embed-actions {
                flex-direction: column;
            }
            
            .auto-embed-actions .btn {
                min-width: auto;
            }
            
            .embed-option {
                flex-direction: column;
                align-items: flex-start;
                gap: 10px;
            }
            
            .embed-option label {
                min-width: auto;
            }
            
            .tmdb-update-container {
                flex-direction: column;
                align-items: stretch;
            }
            
            .tmdb-input-wrapper {
                min-width: auto;
                margin-bottom: 10px;
            }
            
            .tmdb-update-btn {
                width: 100%;
            }
        }

        @media (max-width: 480px) {
            :root {
                --bottom-bar-height: 70px;
            }
            
            body {
                padding: max(10px, env(safe-area-inset-top)) max(10px, env(safe-area-inset-right)) calc(var(--bottom-bar-height) + max(10px, env(safe-area-inset-bottom))) max(10px, env(safe-area-inset-left));
            }
            
            .nav-container {
                padding: 0 5px;
            }
            
            .nav-item {
                min-width: 50px;
                padding: 6px 8px;
            }
            
            .nav-label {
                font-size: 0.65rem;
            }
            
            .nav-icon {
                font-size: 1.1rem;
            }
            
            header {
                padding: 15px;
                margin-bottom: 20px;
            }
            
            .card {
                padding: 15px;
                margin-bottom: 15px;
            }
            
            .preview-grid {
                grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
                gap: 10px;
            }
            
            .modal-content {
                width: 95%;
                margin: 2% auto;
                padding: 20px;
            }
        }

        /* Landscape orientation for mobile */
        @media (max-width: 768px) and (orientation: landscape) {
            :root {
                --bottom-bar-height: 60px;
            }
            
            body {
                padding: max(10px, env(safe-area-inset-top)) max(10px, env(safe-area-inset-right)) calc(var(--bottom-bar-height) + max(10px, env(safe-area-inset-bottom))) max(10px, env(safe-area-inset-left));
            }
            
            .nav-item {
                padding: 4px 8px;
            }
            
            .nav-icon {
                font-size: 1rem;
                margin-bottom: 2px;
            }
            
            .nav-label {
                font-size: 0.6rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>📁 Playlist Categories Manager</h1>
            <p class="subtitle">Manage content in Categories structure with Movies, TV Series, and Live TV</p>
        </header>

        <!-- TMDB Generator Tab -->
        <div id="tmdb-generator" class="tab-content active">
            <div class="grid grid-2">
                <div class="card">
                    <h2>🎬 Movie Generator</h2>
                    <div class="form-group">
                        <label>TMDB Movie ID</label>
                        <input type="number" id="movie-tmdb-id" placeholder="e.g., 550 (Fight Club)">
                    </div>
                    <div class="form-group">
                        <label>Additional Servers</label>
                        <div id="movie-servers" class="server-list">
                                                    <div class="server-item">
                            <input type="text" placeholder="Server Name" class="server-name">
                            <input type="url" placeholder="Video URL" class="server-url">
                            <button class="paste-btn" onclick="pasteFromClipboard(this)">📋 Paste</button>
                            <button class="btn btn-danger btn-small" onclick="removeServer(this)">Remove</button>
                        </div>
                        </div>
                        <button class="btn btn-secondary btn-small" onclick="addServer('movie-servers')">+ Add Server</button>
                    </div>
                    <button class="btn btn-primary" onclick="generateFromTMDB('movie')">
                        <span class="loading" id="movie-loading" style="display: none;"></span>
                        Generate Movie
                    </button>
                </div>

                <div class="card">
                    <h2>📺 TV Series Generator</h2>
                    <div class="form-group">
                        <label>TMDB TV Series ID</label>
                        <input type="number" id="series-tmdb-id" placeholder="e.g., 1399 (Game of Thrones)">
                    </div>
                    <div class="form-group">
                        <label>Seasons to Include</label>
                        <input type="text" id="series-seasons" placeholder="e.g., 1,2,3 or leave empty for all">
                    </div>
                    <div class="form-group">
                        <label>Additional Servers</label>
                        <div id="series-servers" class="server-list">
                                                    <div class="server-item">
                            <input type="text" placeholder="Server Name" class="server-name">
                            <input type="url" placeholder="Video URL Template (use {season} {episode})" class="server-url">
                            <button class="paste-btn" onclick="pasteFromClipboard(this)">📋 Paste</button>
                            <button class="btn btn-danger btn-small" onclick="removeServer(this)">Remove</button>
                        </div>
                        </div>
                        <button class="btn btn-secondary btn-small" onclick="addServer('series-servers')">+ Add Server</button>
                    </div>
                    <button class="btn btn-primary" onclick="generateFromTMDB('series')">
                        <span class="loading" id="series-loading" style="display: none;"></span>
                        Generate Series
                    </button>
                </div>
            </div>

            <div class="card">
                <h2>🔍 TMDB Search & Preview</h2>
                <div class="grid">
                    <div class="form-group">
                        <label>Search Query</label>
                        <input type="text" id="tmdb-search" placeholder="Search for movies or TV shows...">
                    </div>
                    <div class="form-group">
                        <label>Content Type</label>
                        <select id="search-type">
                            <option value="multi">All</option>
                            <option value="movie">Movies</option>
                            <option value="tv">TV Shows</option>
                        </select>
                    </div>
                </div>
                <button class="btn btn-primary" onclick="searchTMDB()">
                    <span class="loading" id="search-loading" style="display: none;"></span>
                    Search TMDB
                </button>
                <div id="search-results" class="preview-grid"></div>
            </div>
        </div>

        <!-- Manual Input Tab -->
        <div id="manual-input" class="tab-content">
            <div class="card">
                <h2>✏️ Manual Content Input</h2>
                <div class="grid">
                    <div class="form-group">
                        <label>Content Type</label>
                        <select id="manual-type" onchange="toggleManualFields()">
                            <option value="movie">Movie</option>
                            <option value="series">TV Series</option>
                            <option value="live">Live TV</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>SubCategory</label>
                        <select id="manual-subcategory">
                            <option value="Action">Action</option>
                            <option value="Comedy">Comedy</option>
                            <option value="Drama">Drama</option>
                            <option value="Horror">Horror</option>
                            <option value="Sci-Fi">Sci-Fi</option>
                            <option value="Anime">Anime</option>
                            <option value="Entertainment">Entertainment</option>
                        </select>
                    </div>
                </div>
                
                <div class="grid">
                    <div class="form-group">
                        <label>Title</label>
                        <input type="text" id="manual-title" placeholder="Content title">
                    </div>
                    <div class="form-group">
                        <label>Country</label>
                        <input type="text" id="manual-country" placeholder="Country (optional)">
                    </div>
                </div>
                
                <div class="grid">
                    <div class="form-group">
                        <label>Description</label>
                        <textarea id="manual-description" rows="4" placeholder="Content description"></textarea>
                    </div>
                    <div class="form-group">
                        <label>Image/Poster URL</label>
                        <input type="url" id="manual-image" placeholder="https://...">
                    </div>
                </div>

                <div class="grid">
                    <div class="form-group">
                        <label>Year</label>
                        <input type="number" id="manual-year" min="1900" max="2030">
                    </div>
                    <div class="form-group">
                        <label>Rating (IMDB)</label>
                        <input type="number" id="manual-rating" min="0" max="10" step="0.1">
                    </div>
                </div>

                <div class="form-group">
                    <label>Video Sources</label>
                    <div id="manual-sources" class="server-list">
                        <div class="server-item">
                            <input type="text" placeholder="Source Name" class="source-name">
                            <input type="url" placeholder="Video URL" class="source-url">
                            <select class="source-type">
                                <option value="video">Direct Video</option>
                                <option value="embed">Embedded</option>
                                <option value="youtube">YouTube</option>
                                <option value="live">Live Stream</option>
                            </select>
                            <select class="source-quality">
                                <option value="1080p">1080p</option>
                                <option value="720p">720p</option>
                                <option value="480p">480p</option>
                                <option value="Auto">Auto</option>
                            </select>
                            <button class="paste-btn" onclick="pasteFromClipboard(this)">📋 Paste</button>
                            <button class="btn btn-danger btn-small" onclick="removeServer(this)">Remove</button>
                        </div>
                    </div>
                    <button class="btn btn-secondary btn-small" onclick="addManualSource()">+ Add Source</button>
                </div>

                <div id="series-fields" style="display: none;">
                    <div class="form-group">
                        <label>Number of Seasons</label>
                        <input type="number" id="manual-seasons" min="1" onchange="generateSeasonFields()">
                    </div>
                    <div id="season-container"></div>
                </div>

                <button class="btn btn-primary" onclick="addManualContent()">Add Content</button>
            </div>
        </div>

        <!-- Bulk Operations Tab -->
        <div id="bulk-operations" class="tab-content">
            <div class="grid">
                <div class="card">
                    <h2>📅 Year-based Bulk Generation</h2>
                    <div class="form-group">
                        <label>Content Type</label>
                        <select id="bulk-type">
                            <option value="movie">Movies</option>
                            <option value="tv">TV Shows</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Year</label>
                        <input type="number" id="bulk-year" min="1900" max="2030" value="2023">
                    </div>
                    <div class="form-group">
                        <label>Number of Pages</label>
                        <input type="number" id="bulk-pages" min="1" max="20" value="5">
                    </div>
                    <div class="form-group">
                        <label>
                            <input type="checkbox" id="bulk-skip-duplicates" checked>
                            Skip Duplicates
                        </label>
                    </div>
                    <button class="btn btn-primary" onclick="bulkGenerate()">
                        <span class="loading" id="bulk-loading" style="display: none;"></span>
                        Start Bulk Generation
                    </button>
                    <div class="progress-bar">
                        <div class="progress-fill" id="bulk-progress"></div>
                    </div>
                    <div id="bulk-status"></div>
                </div>

                <div class="card">
                    <h2>🎯 Genre-based Generation</h2>
                    <div class="form-group">
                        <label>Genre</label>
                        <select id="genre-select">
                            <option value="28">Action</option>
                            <option value="12">Adventure</option>
                            <option value="16">Animation</option>
                            <option value="35">Comedy</option>
                            <option value="80">Crime</option>
                            <option value="99">Documentary</option>
                            <option value="18">Drama</option>
                            <option value="10751">Family</option>
                            <option value="14">Fantasy</option>
                            <option value="36">History</option>
                            <option value="27">Horror</option>
                            <option value="10402">Music</option>
                            <option value="9648">Mystery</option>
                            <option value="10749">Romance</option>
                            <option value="878">Science Fiction</option>
                            <option value="10770">TV Movie</option>
                            <option value="53">Thriller</option>
                            <option value="10752">War</option>
                            <option value="37">Western</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Number of Items</label>
                        <input type="number" id="genre-count" min="1" max="100" value="20">
                    </div>
                    <button class="btn btn-primary" onclick="generateByGenre()">Generate by Genre</button>
                </div>
            </div>
        </div>

        <!-- Data Management Tab -->
        <div id="data-management" class="tab-content">
            <div class="grid">
                <div class="card">
                    <h2>📂 Import/Export</h2>
                    <div class="form-group">
                        <label>Import JSON File</label>
                        <input type="file" id="import-file" accept=".json">
                        <div style="display: flex; gap: 10px; flex-wrap: wrap; margin-top: 10px;">
                            <button class="btn btn-secondary" onclick="importData()">
                                <span class="loading" id="import-loading" style="display: none;"></span>
                                Standard Import
                            </button>
                            <button class="btn btn-primary" onclick="importDataChunked()">
                                <span class="loading" id="import-chunked-loading" style="display: none;"></span>
                                🚀 Chunked Import (Large Files)
                            </button>
                        </div>
                        <small style="color: var(--text-secondary); margin-top: 5px; display: block;">
                            💡 Use "Chunked Import" for large files (>5MB) to prevent crashes
                        </small>
                    </div>
                    
                    <!-- Import Progress Section -->
                    <div id="import-progress-section" style="display: none;">
                        <div class="form-group">
                            <label>Import Progress</label>
                            <div class="progress-bar">
                                <div class="progress-fill" id="import-progress-fill"></div>
                            </div>
                            <div id="import-progress-text" class="status info" style="margin-top: 10px;"></div>
                        </div>
                        <div class="form-group">
                            <div id="import-stats" class="status info">
                                <div>📊 <span id="import-processed">0</span> / <span id="import-total">0</span> entries processed</div>
                                <div>⏱️ Estimated time remaining: <span id="import-eta">Calculating...</span></div>
                                <div>🚀 Processing speed: <span id="import-speed">0</span> entries/sec</div>
                                <div>📂 Current category: <span id="import-current-category">-</span></div>
                            </div>
                        </div>
                        <div class="form-group">
                            <button class="btn btn-danger" id="cancel-import-btn" onclick="cancelImport()" style="display: none;">Cancel Import</button>
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <button class="btn btn-primary" onclick="exportData()">Export Current Data</button>
                        <button class="btn btn-warning" onclick="exportSample()">Export Sample Format</button>
                    </div>
                </div>

                <div class="card">
                    <h2>🗑️ Data Management</h2>
                    <div class="form-group">
                        <button class="btn btn-danger" onclick="clearAllData()">Clear All Data</button>
                        <button class="btn btn-warning" onclick="removeDuplicates()">Remove Duplicates</button>
                        <button class="btn btn-secondary" onclick="migrateStorage()">🔄 Migrate Storage</button>
                        <button class="btn btn-secondary" onclick="optimizeStorage()">⚡ Optimize Storage</button>
                    </div>
                    <div class="form-group">
                        <label>Current Data Count</label>
                        <div id="data-stats">
                            <div>Movies: <span id="movie-count">0</span></div>
                            <div>Series: <span id="series-count">0</span></div>
                            <div>Channels: <span id="channel-count">0</span></div>
                            <div>Total Items: <span id="total-count">0</span></div>
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Storage Information</label>
                        <div id="storage-info" class="status info">
                            <div>Storage Type: <span id="storage-type">localStorage</span></div>
                            <div>Data Size: <span id="data-size">0 KB</span></div>
                            <div>Compression: <span id="compression-status">None</span></div>
                        </div>
                    </div>
                </div>

                <div class="card">
                    <h2>🔗 Auto-Embed Server Management</h2>
                    <div class="form-group">
                        <label>Auto-Embed Configuration</label>
                        <div class="auto-embed-config">
                            <div class="embed-option">
                                <input type="checkbox" id="auto-vidsrc" checked>
                                <label for="auto-vidsrc">VidSrc.net Auto-Embed</label>
                                <select id="vidsrc-quality">
                                    <option value="1080p">1080p</option>
                                    <option value="720p">720p</option>
                                    <option value="480p">480p</option>
                                </select>
                            </div>
                            <div class="embed-option">
                                <input type="checkbox" id="auto-vidjoy" checked>
                                <label for="auto-vidjoy">VidJoy.pro Auto-Embed</label>
                                <select id="vidjoy-quality">
                                    <option value="1080p">1080p</option>
                                    <option value="720p">720p</option>
                                    <option value="480p">480p</option>
                                </select>
                            </div>
                            <div class="embed-option">
                                <input type="checkbox" id="auto-multiembed" checked>
                                <label for="auto-multiembed">MultiEmbed.mov Auto-Embed</label>
                                <select id="multiembed-quality">
                                    <option value="1080p">1080p</option>
                                    <option value="720p">720p</option>
                                    <option value="480p">480p</option>
                                </select>
                            </div>
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Select Content to Auto-Embed (Max 10 items)</label>
                        <div class="checkbox-content-container" id="checkbox-content-container">
                            <div class="checkbox-header">
                                <button class="btn btn-secondary btn-small" onclick="refreshContentCheckboxes()">🔄 Refresh List</button>
                                <button class="btn btn-danger btn-small" onclick="clearAllSelections()">❌ Clear All</button>
                                <span id="selection-counter" class="selection-counter">Selected: 0/10</span>
                            </div>
                            <div id="content-checkbox-list" class="content-checkbox-list">
                                <!-- Checkboxes will be populated here -->
                            </div>
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Bulk Update Selected Content</label>
                        <div class="bulk-update-container">
                            <button class="btn btn-success" id="bulk-update-btn" onclick="bulkUpdateSelectedContent()" disabled>
                                🚀 Update Selected Content with TMDB Metadata & Sources
                            </button>
                            <div id="bulk-update-progress" class="progress-bar" style="display: none;">
                                <div class="progress-fill" id="bulk-update-progress-fill"></div>
                            </div>
                            <div id="bulk-update-status" class="status info" style="display: none;"></div>
                        </div>
                    </div>
                    <div class="form-group">
                        <div id="selected-content-info" class="status info" style="display: none;"></div>
                    </div>
                    <div class="form-group">
                        <label>Apply Auto-Embed to All Content</label>
                        <div class="auto-embed-actions">
                            <button class="btn btn-warning" onclick="applyAutoEmbedToMovies()">Apply to All Movies</button>
                            <button class="btn btn-warning" onclick="applyAutoEmbedToSeries()">Apply to All TV Series</button>
                            <button class="btn btn-success" onclick="applyAutoEmbedToAll()">Apply to All Content</button>
                        </div>
                    </div>
                    <div class="form-group">
                        <div id="auto-embed-status" class="status info" style="display: none;"></div>
                    </div>
                </div>
            </div>

            <div class="card">
                <h2>👁️ Content Preview & Management</h2>
                <div class="form-group">
                    <label>Filter by Type</label>
                    <select id="preview-filter" onchange="updatePreview()">
                        <option value="all">All Content</option>
                        <option value="movie">Movies</option>
                        <option value="series">TV Series</option>
                        <option value="live">Live TV</option>
                    </select>
                </div>
                <div id="content-preview" class="preview-grid"></div>
            </div>
        </div>
    </div>

    <!-- Bottom Navigation Bar -->
    <nav class="bottom-nav" role="navigation" aria-label="Main navigation">
        <div class="nav-container">
            <div class="nav-item active" onclick="switchTab('tmdb-generator')" role="button" tabindex="0" aria-label="TMDB Generator">
                <div class="nav-icon">🎭</div>
                <div class="nav-label">TMDB</div>
            </div>
            <div class="nav-item" onclick="switchTab('manual-input')" role="button" tabindex="0" aria-label="Manual Input">
                <div class="nav-icon">✏️</div>
                <div class="nav-label">Manual</div>
            </div>
            <div class="nav-item" onclick="switchTab('bulk-operations')" role="button" tabindex="0" aria-label="Bulk Operations">
                <div class="nav-icon">📦</div>
                <div class="nav-label">Bulk</div>
            </div>
            <div class="nav-item" onclick="switchTab('data-management')" role="button" tabindex="0" aria-label="Data Management">
                <div class="nav-icon">🗂️</div>
                <div class="nav-label">Data</div>
            </div>
        </div>
    </nav>

    <!-- Edit Modal -->
    <div id="edit-modal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeEditModal()">&times;</span>
            <h2>Edit Content</h2>
            <div id="edit-form"></div>
            <button class="btn btn-primary" onclick="saveEdit()">Save Changes</button>
        </div>
    </div>

    <script>
        // Configuration
        const TMDB_API_KEY = 'ec926176bf467b3f7735e3154238c161';
        const TMDB_BASE_URL = 'https://api.themoviedb.org/3';
        const TMDB_IMAGE_BASE = 'https://image.tmdb.org/t/p/w500';
        const VIDSRC_BASE = 'https://vidsrc.net/embed';
        const VIDJOY_BASE = 'https://vidjoy.pro/embed';
        const MULTIEMBED_BASE = 'https://multiembed.mov/directstream.php';

        // Global data storage
        let currentData = {
            Categories: [
                {
                    MainCategory: "Live TV",
                    SubCategories: ["Entertainment"],
                    Entries: []
                },
                {
                    MainCategory: "Movies", 
                    SubCategories: ["Action", "Comedy", "Drama", "Horror", "Sci-Fi"],
                    Entries: []
                },
                {
                    MainCategory: "TV Series",
                    SubCategories: ["Anime", "Action", "Comedy", "Drama"],
                    Entries: []
                }
            ]
        };

        let nextId = 1;

                 // Initialize
         document.addEventListener('DOMContentLoaded', async function() {
             showStatus('info', 'Loading saved data...');
             await loadSavedData();
                         updateDataStats();
            updatePreview();
            updateAutoEmbedStatus();
            refreshContentCheckboxes();
            showStatus('success', 'Application loaded successfully!');
             
             // Add event listeners for auto-embed configuration
             const autoEmbedElements = [
                 'auto-vidsrc', 'vidsrc-quality',
                 'auto-vidjoy', 'vidjoy-quality', 
                 'auto-multiembed', 'multiembed-quality'
             ];
             
             autoEmbedElements.forEach(id => {
                 const element = document.getElementById(id);
                 if (element) {
                     element.addEventListener('change', updateAutoEmbedStatus);
                 }
             });
             
                         // Add test functions to window for debugging
            window.testUnityVerification = function() {
                console.log('🧪 Testing Unity Verification...');
                console.log('📊 Current data structure:');
                console.log('Movies category:', currentData.Categories.find(c => c.MainCategory === "Movies")?.Entries.length || 0, 'entries');
                console.log('TV Series category:', currentData.Categories.find(c => c.MainCategory === "TV Series")?.Entries.length || 0, 'entries');
                console.log('Live TV category:', currentData.Categories.find(c => c.MainCategory === "Live TV")?.Entries.length || 0, 'entries');
                
                console.log('\n🎬 Test movie generation: Fight Club (ID: 550)');
                generateFromTMDB('movie', 550);
                
                console.log('📺 Test series generation: Game of Thrones (ID: 1399)');
                generateFromTMDB('series', 1399);
                
                console.log('\n✅ Check console logs above to verify:');
                console.log('1. Movies should go to Movies category');
                console.log('2. Series should go to TV Series category');
                console.log('3. Season numbers should be 1, 2, 3... not concatenated');
                console.log('4. Generate buttons in search results should work');
            };
            
            window.testSourceGeneration = function() {
                 console.log('Testing source generation...');
                 console.log('VIDSRC_BASE:', VIDSRC_BASE);
                 console.log('VIDJOY_BASE:', VIDJOY_BASE);
                 
                 // Test movie source generation with multiple quality options (separate sources)
                 const testMovieId = 550; // Fight Club
                 const movieSources = [
                     {
                         id: 1,
                         type: "embed",
                         title: "VidSrc Server 1080p",
                         quality: "1080p",
                         size: "Auto",
                         kind: "play",
                         premium: "false",
                         external: false,
                         url: `${VIDSRC_BASE}/movie/${testMovieId}`
                     },
                     {
                         id: 2,
                         type: "embed",
                         title: "VidSrc Server 720p",
                         quality: "720p",
                         size: "Auto",
                         kind: "play",
                         premium: "false",
                         external: false,
                         url: `${VIDSRC_BASE}/movie/${testMovieId}`
                     },
                     {
                         id: 3,
                         type: "embed",
                         title: "VidSrc Server 480p",
                         quality: "480p",
                         size: "Auto",
                         kind: "play",
                         premium: "false",
                         external: false,
                         url: `${VIDSRC_BASE}/movie/${testMovieId}`
                     },
                     {
                         id: 4,
                         type: "embed", 
                         title: "VidJoy Server 1080p",
                         quality: "1080p",
                         size: "Auto",
                         kind: "play",
                         premium: "false",
                         external: false,
                         url: `${VIDJOY_BASE}/movie/${testMovieId}`
                     },
                     {
                         id: 5,
                         type: "embed", 
                         title: "VidJoy Server 720p",
                         quality: "720p",
                         size: "Auto",
                         kind: "play",
                         premium: "false",
                         external: false,
                         url: `${VIDJOY_BASE}/movie/${testMovieId}`
                     },
                     {
                         id: 6,
                         type: "embed", 
                         title: "VidJoy Server 480p",
                         quality: "480p",
                         size: "Auto",
                         kind: "play",
                         premium: "false",
                         external: false,
                         url: `${VIDJOY_BASE}/movie/${testMovieId}`
                     }
                 ];
                 
                 console.log('Test movie sources (separate servers):', movieSources);
                 
                 // Test series source generation with multiple quality options (separate sources)
                 const testSeriesId = 1399; // Game of Thrones
                 const seriesSources = [
                     {
                         id: 7,
                         type: "embed",
                         title: "VidSrc Server 1080p",
                         quality: "1080p",
                         size: "Auto",
                         kind: "play",
                         premium: "false",
                         external: false,
                         url: `${VIDSRC_BASE}/tv/${testSeriesId}/1/1`
                     },
                     {
                         id: 8,
                         type: "embed",
                         title: "VidSrc Server 720p",
                         quality: "720p",
                         size: "Auto",
                         kind: "play",
                         premium: "false",
                         external: false,
                         url: `${VIDSRC_BASE}/tv/${testSeriesId}/1/1`
                     },
                     {
                         id: 9,
                         type: "embed",
                         title: "VidSrc Server 480p",
                         quality: "480p",
                         size: "Auto",
                         kind: "play",
                         premium: "false",
                         external: false,
                         url: `${VIDSRC_BASE}/tv/${testSeriesId}/1/1`
                     },
                     {
                         id: 10,
                         type: "embed", 
                         title: "VidJoy Server 1080p",
                         quality: "1080p",
                         size: "Auto",
                         kind: "play",
                         premium: "false",
                         external: false,
                         url: `${VIDJOY_BASE}/tv/${testSeriesId}/1/1`
                     },
                     {
                         id: 11,
                         type: "embed", 
                         title: "VidJoy Server 720p",
                         quality: "720p",
                         size: "Auto",
                         kind: "play",
                         premium: "false",
                         external: false,
                         url: `${VIDJOY_BASE}/tv/${testSeriesId}/1/1`
                     },
                     {
                         id: 12,
                         type: "embed", 
                         title: "VidJoy Server 480p",
                         quality: "480p",
                         size: "Auto",
                         kind: "play",
                         premium: "false",
                         external: false,
                         url: `${VIDJOY_BASE}/tv/${testSeriesId}/1/1`
                     }
                 ];
                 
                 console.log('Test series sources (separate servers):', seriesSources);
                 return { movieSources, seriesSources };
             };
             
             console.log('✅ CineMax Enhanced API Manager loaded!');
             console.log('🎬 Multi-Server Sources: VidSrc.net + VidJoy.pro (Matching existing app structure)');
             console.log('🔧 Fixed: Root-level movies array for GenreActivity & TV Series');
             console.log('🎯 Fixed: Source kind values - "play" for embeds/live TV, "both" for direct links');
             console.log('📺 Enhanced: Multiple quality options per server (1080p + 720p + 480p)');
             console.log('🆕 NEW: Server editing in Data Management tab');
             console.log('🆕 NEW: Add server functionality for movies and TV series episodes');
             console.log('🆕 NEW: Paste button for each server input field');
             console.log('🆕 NEW: Quick add server to content and episodes');
             console.log('🧪 Test with: testSourceGeneration()');
             
             // Show info about the fix
             setTimeout(() => {
                 showStatus('success', 'ENHANCED: Multi-server sources matching existing app structure! No CineMax changes needed!');
             }, 2000);
         });

        // Tab switching
        function switchTab(tabName) {
            // Remove active class from all nav items and tab contents
            document.querySelectorAll('.nav-item').forEach(nav => nav.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            // Add active class to clicked nav item
            event.target.closest('.nav-item').classList.add('active');
            
            // Show corresponding tab content
            document.getElementById(tabName).classList.add('active');
            
            // Update accessibility attributes
            document.querySelectorAll('.nav-item').forEach(nav => nav.setAttribute('aria-selected', 'false'));
            event.target.closest('.nav-item').setAttribute('aria-selected', 'true');
        }
        
        // Keyboard navigation support
        document.addEventListener('DOMContentLoaded', function() {
            document.querySelectorAll('.nav-item').forEach(item => {
                item.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        item.click();
                    }
                });
            });
        });

        // Handle Enter key in TMDB ID input
        function handleTmdbEnterKey(event) {
            if (event.key === 'Enter') {
                event.preventDefault();
                const selectElement = document.getElementById('auto-embed-content-select');
                if (selectElement.value) {
                    applyAutoEmbedToSelected();
                } else {
                    showStatus('warning', 'Please select content first before updating TMDB ID');
                }
            }
        }

        // TMDB API functions
        async function fetchTMDB(endpoint, params = {}) {
            const url = new URL(`${TMDB_BASE_URL}${endpoint}`);
            url.searchParams.append('api_key', TMDB_API_KEY);
            
            Object.entries(params).forEach(([key, value]) => {
                url.searchParams.append(key, value);
            });

            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`TMDB API error: ${response.status}`);
                return await response.json();
            } catch (error) {
                console.error('TMDB fetch error:', error);
                showStatus('error', `TMDB API Error: ${error.message}`);
                return null;
            }
        }

        async function searchTMDB() {
            const query = document.getElementById('tmdb-search').value.trim();
            const type = document.getElementById('search-type').value;
            
            if (!query) {
                showStatus('warning', 'Please enter a search query');
                return;
            }

            showLoading('search-loading', true);
            
            const endpoint = type === 'multi' ? '/search/multi' : `/search/${type}`;
            const results = await fetchTMDB(endpoint, { query });
            
            showLoading('search-loading', false);
            
            if (results && results.results) {
                displaySearchResults(results.results);
            }
        }

        function displaySearchResults(results) {
            const container = document.getElementById('search-results');
            container.innerHTML = '';

            results.slice(0, 20).forEach(item => {
                const div = document.createElement('div');
                div.className = 'preview-item';
                
                // Determine media type with robust detection
                let mediaType;
                if (item.media_type) {
                    // Multi search provides media_type
                    mediaType = item.media_type;
                } else {
                    // Specific searches don't provide media_type, detect by properties
                    mediaType = item.title ? 'movie' : 'tv';
                }
                
                // Convert to generator type (our functions expect 'series' not 'tv')
                const generatorType = mediaType === 'tv' ? 'series' : 'movie';
                
                const title = item.title || item.name;
                
                // Debug logging (can be removed in production)
                console.log(`🔍 Search result: ${title} → ${mediaType} → ${generatorType}`);
                const year = (item.release_date || item.first_air_date || '').substring(0, 4);
                const poster = item.poster_path ? `${TMDB_IMAGE_BASE}${item.poster_path}` : 'https://via.placeholder.com/300x450?text=No+Image';

                div.innerHTML = `
                    <img src="${poster}" alt="${title}" loading="lazy">
                    <div class="info">
                        <div class="title">${title}</div>
                        <div class="meta">${year} • ${mediaType.toUpperCase()} • ID: ${item.id}</div>
                        <button class="btn btn-primary btn-small" onclick="generateFromTMDB('${generatorType}', ${item.id})">
                            Generate
                        </button>
                    </div>
                `;
                
                container.appendChild(div);
            });
        }

                 async function generateFromTMDB(type, tmdbId = null) {
             console.log(`🎬 generateFromTMDB called with type: '${type}', tmdbId: ${tmdbId}`);
             
             const id = tmdbId || document.getElementById(`${type}-tmdb-id`).value;
             
             if (!id) {
                 showStatus('warning', 'Please enter a TMDB ID');
                 return;
             }

             showLoading(`${type}-loading`, true);
             showStatus('info', `Generating ${type} with automatic VidSrc & VidJoy sources...`);
             
             try {
                 if (type === 'movie') {
                     console.log(`🎞️ Generating movie with ID: ${id}`);
                     await generateMovie(id);
                 } else if (type === 'series') {
                     console.log(`📺 Generating series with ID: ${id}`);
                     await generateSeries(id);
                 } else {
                     throw new Error(`Unknown content type: '${type}'. Expected 'movie' or 'series'.`);
                 }
                 
                 updateDataStats();
                 updatePreview();
                 showStatus('success', `${type} generated successfully with automatic video sources!`);
             } catch (error) {
                 showStatus('error', `Error generating ${type}: ${error.message}`);
             }
             
             showLoading(`${type}-loading`, false);
         }

                 async function generateMovie(tmdbId) {
             const movieData = await fetchTMDB(`/movie/${tmdbId}`);
             const credits = await fetchTMDB(`/movie/${tmdbId}/credits`);
             const videos = await fetchTMDB(`/movie/${tmdbId}/videos`);
             
             if (!movieData) throw new Error('Failed to fetch movie data');

             // Get additional servers
             const serverInputs = document.querySelectorAll('#movie-servers .server-item');
             const additionalSources = [];
             
             serverInputs.forEach(item => {
                 const name = item.querySelector('.server-name').value.trim();
                 const url = item.querySelector('.server-url').value.trim();
                 if (name && url) {
                     additionalSources.push({
                         id: nextId++,
                         type: getSourceType(url),
                         title: name,
                         quality: "Auto",
                         size: "Unknown",
                         kind: getSourceKind(url),
                         premium: "false",
                         external: false,
                         url: url
                     });
                 }
             });

                         // Auto-generate embed sources based on configuration
            const autoSources = generateEmbedSources(tmdbId, 'movie');

             console.log('Auto-generated movie sources:', autoSources);
             console.log('Additional sources:', additionalSources);

             const movie = {
                 id: nextId++,
                 title: movieData.title,
                 type: "movie",
                 label: movieData.genres[0]?.name || "Movie",
                 sublabel: `Released ${movieData.release_date?.substring(0, 4) || 'Unknown'}`,
                 imdb: movieData.vote_average?.toString() || "0",
                 downloadas: `${movieData.title.toLowerCase().replace(/\s+/g, '-')}.mp4`,
                 comment: true,
                 playas: "video",
                 description: movieData.overview || "No description available",
                 classification: getRatingClassification(movieData.adult),
                 year: movieData.release_date?.substring(0, 4) || "Unknown",
                 duration: formatDuration(movieData.runtime),
                 rating: movieData.vote_average || 0,
                 image: movieData.poster_path ? `${TMDB_IMAGE_BASE}${movieData.poster_path}` : null,
                 cover: movieData.backdrop_path ? `${TMDB_IMAGE_BASE}${movieData.backdrop_path}` : null,
                 genres: movieData.genres?.map(g => ({ id: g.id, title: g.name })) || [],
                 sources: [...autoSources, ...additionalSources],
                 trailer: getTrailer(videos),
                 actors: getActors(credits),
                 subtitles: await getSubtitles(tmdbId, 'movie'),
                 views: Math.floor(Math.random() * 10000) + 1000,
                 created_at: new Date().toISOString().split('T')[0]
             };

             console.log('Generated movie with sources:', movie.sources);

            // Convert to Categories structure
            const movieEntry = {
                Title: movie.title,
                SubCategory: movie.genres?.[0]?.title || "Action",
                Country: "",
                Description: movie.description,
                Poster: movie.image,
                Thumbnail: movie.image,
                Rating: Math.round(movie.rating),
                Duration: movie.duration,
                Year: parseInt(movie.year),
                Servers: movie.sources.map(source => ({
                    name: source.title,
                    url: source.url
                }))
            };

            // Add to Movies category
            const moviesCategory = currentData.Categories.find(cat => cat.MainCategory === "Movies");
            if (moviesCategory) {
                // Add genre to subcategories if not exists
                const genre = movie.genres?.[0]?.title || "Action";
                if (!moviesCategory.SubCategories.includes(genre)) {
                    moviesCategory.SubCategories.push(genre);
                }
                moviesCategory.Entries.push(movieEntry);
                console.log(`✅ Movie '${movieEntry.Title}' added to Movies category with ${movieEntry.Servers.length} servers`);
            } else {
                console.error('❌ Movies category not found!');
            }
            
            await saveData();
        }

        async function generateSeries(tmdbId) {
            const seriesData = await fetchTMDB(`/tv/${tmdbId}`);
            const credits = await fetchTMDB(`/tv/${tmdbId}/credits`);
            const videos = await fetchTMDB(`/tv/${tmdbId}/videos`);
            
            if (!seriesData) throw new Error('Failed to fetch series data');

            // Get seasons to include
            const seasonsInput = document.getElementById('series-seasons').value.trim();
            const seasonsToInclude = seasonsInput ? 
                seasonsInput.split(',').map(s => parseInt(s.trim())).filter(s => !isNaN(s)) :
                seriesData.seasons?.map(s => s.season_number).filter(s => s > 0) || [];

            // Get additional servers
            const serverInputs = document.querySelectorAll('#series-servers .server-item');
            const additionalServerTemplates = [];
            
            serverInputs.forEach(item => {
                const name = item.querySelector('.server-name').value.trim();
                const urlTemplate = item.querySelector('.server-url').value.trim();
                if (name && urlTemplate) {
                    additionalServerTemplates.push({ name, urlTemplate });
                }
            });

            const seasons = [];
            
            for (const seasonNum of seasonsToInclude) {
                const seasonData = await fetchTMDB(`/tv/${tmdbId}/season/${seasonNum}`);
                if (!seasonData) continue;

                const episodes = [];
                
                                 for (const episodeData of seasonData.episodes || []) {
                     // Auto-generate embed sources based on configuration for each episode
                     const episodeSources = generateEmbedSources(tmdbId, 'tv', seasonNum, episodeData.episode_number);

                     console.log(`Auto-generated sources for S${seasonNum}E${episodeData.episode_number}:`, episodeSources);

                    // Add additional sources
                    additionalServerTemplates.forEach(server => {
                        const url = server.urlTemplate
                            .replace('{season}', seasonNum)
                            .replace('{episode}', episodeData.episode_number);
                        
                        episodeSources.push({
                            id: nextId++,
                            type: getSourceType(url),
                            title: server.name,
                            quality: "Auto",
                            size: "Unknown",
                            kind: getSourceKind(url),
                            premium: "false",
                            external: false,
                            url: url
                        });
                    });

                    episodes.push({
                        id: nextId++,
                        episode_number: episodeData.episode_number,
                        title: episodeData.name || `Episode ${episodeData.episode_number}`,
                        description: episodeData.overview || "No description available",
                        downloadas: `${seriesData.name.toLowerCase().replace(/\s+/g, '-')}-s${seasonNum}e${episodeData.episode_number}.mp4`,
                        playas: "video",
                        duration: formatDuration(episodeData.runtime),
                        image: episodeData.still_path ? `${TMDB_IMAGE_BASE}${episodeData.still_path}` : null,
                        sources: episodeSources
                    });
                }

                seasons.push({
                    id: seasonNum,
                    title: seasonData.name || `Season ${seasonNum}`,
                    episodes: episodes
                });
            }

            const series = {
                id: nextId++,
                title: seriesData.name,
                type: "series",
                label: seriesData.genres[0]?.name || "Series",
                sublabel: `${seasons.length} Season${seasons.length !== 1 ? 's' : ''}`,
                imdb: seriesData.vote_average?.toString() || "0",
                downloadas: seriesData.name.toLowerCase().replace(/\s+/g, '-'),
                comment: true,
                playas: "video",
                description: seriesData.overview || "No description available",
                classification: getRatingClassification(seriesData.adult),
                year: seriesData.first_air_date?.substring(0, 4) || "Unknown",
                duration: formatDuration(seriesData.episode_run_time?.[0]),
                rating: seriesData.vote_average || 0,
                image: seriesData.poster_path ? `${TMDB_IMAGE_BASE}${seriesData.poster_path}` : null,
                cover: seriesData.backdrop_path ? `${TMDB_IMAGE_BASE}${seriesData.backdrop_path}` : null,
                genres: seriesData.genres?.map(g => ({ id: g.id, title: g.name })) || [],
                sources: [], // Series don't have direct sources
                trailer: getTrailer(videos),
                actors: getActors(credits),
                subtitles: [],
                seasons: seasons,
                views: Math.floor(Math.random() * 10000) + 1000,
                created_at: new Date().toISOString().split('T')[0]
            };

            // Convert to Categories structure
            const seriesEntry = {
                Title: series.title,
                SubCategory: series.genres?.[0]?.title || "Action",
                Country: "",
                Description: series.description,
                Poster: series.image,
                Thumbnail: series.image,
                Rating: Math.round(series.rating),
                Year: parseInt(series.year),
                Seasons: seasons.map(season => ({
                    Season: season.id,
                    SeasonPoster: series.image,
                    Episodes: season.episodes.map(episode => ({
                        Episode: episode.episode_number,
                        Title: episode.title,
                        Duration: episode.duration || "00:45:00",
                        Description: episode.description || "",
                        Thumbnail: episode.image || series.image,
                        Servers: episode.sources?.map(source => ({
                            name: source.title,
                            url: source.url
                        })) || []
                    }))
                }))
            };

            // Add to TV Series category
            const seriesCategory = currentData.Categories.find(cat => cat.MainCategory === "TV Series");
            if (seriesCategory) {
                // Add genre to subcategories if not exists
                const genre = series.genres?.[0]?.title || "Action";
                if (!seriesCategory.SubCategories.includes(genre)) {
                    seriesCategory.SubCategories.push(genre);
                }
                seriesCategory.Entries.push(seriesEntry);
                console.log(`✅ Series '${seriesEntry.Title}' added to TV Series category with ${seriesEntry.Seasons.length} seasons`);
            } else {
                console.error('❌ TV Series category not found!');
            }
            
            await saveData();
        }

        // Helper functions
        function getSourceType(url) {
            if (url.includes('youtube.com') || url.includes('youtu.be')) return 'youtube';
            if (url.includes('embed') || url.includes('iframe')) return 'embed';
            if (url.includes('.m3u8')) return 'm3u8';
            if (url.includes('.mpd')) return 'dash';
            return 'video';
        }

        function getSourceKind(url) {
            const type = getSourceType(url);
            if (type === 'youtube') return 'youtube';
            if (type === 'embed') return 'play';     // Embed sources = play only
            if (type === 'm3u8' || type === 'dash') return 'play';  // Live TV/streams = play only
            if (type === 'video') return 'both';     // Direct video files = both downloadable & playable
            return 'both';  // Default for direct links
        }

        function getRatingClassification(adult) {
            return adult ? 'R' : 'PG-13';
        }

        function formatDuration(minutes) {
            if (!minutes) return "Unknown";
            const hours = Math.floor(minutes / 60);
            const mins = minutes % 60;
            return hours > 0 ? `${hours}:${mins.toString().padStart(2, '0')}` : `${mins}:00`;
        }

        function getTrailer(videos) {
            if (!videos?.results) return null;
            
            const trailer = videos.results.find(v => 
                v.type === 'Trailer' && v.site === 'YouTube'
            ) || videos.results[0];
            
            if (trailer && trailer.site === 'YouTube') {
                return {
                    id: nextId++,
                    type: "youtube",
                    title: `${trailer.name} Trailer`,
                    url: `https://www.youtube.com/watch?v=${trailer.key}`
                };
            }
            
            return null;
        }

        function getActors(credits) {
            if (!credits?.cast) return [];
            
            return credits.cast.slice(0, 10).map(actor => ({
                id: nextId++,
                name: actor.name,
                type: actor.gender === 1 ? "actress" : "actor",
                role: actor.character || "Unknown Role",
                image: actor.profile_path ? `${TMDB_IMAGE_BASE}${actor.profile_path}` : null,
                bio: "Actor information from TMDB"
            }));
        }

                 async function getSubtitles(tmdbId, type) {
             // This would integrate with a subtitle API
             // For now, return empty array
             return [];
         }

         // Helper functions for generating root-level arrays
         function generateActorsFromContent() {
             const actorMap = new Map();
             
             // Process both slides and featuredMovies to ensure all actors are captured
             const allContent = [
                 ...(currentData.home.slides || []).map(slide => slide.poster || slide),
                 ...(currentData.home.featuredMovies || [])
             ];
             
             allContent.forEach(content => {
                 if (content && content.actors && Array.isArray(content.actors)) {
                     content.actors.forEach(actor => {
                         if (actor.name && !actorMap.has(actor.name)) {
                             actorMap.set(actor.name, {
                                 id: actor.id || nextId++,
                                 name: actor.name,
                                 type: actor.type || 'actor',
                                 role: actor.role || 'Actor',
                                 image: actor.image || '',
                                 born: actor.born || '',
                                 height: actor.height || '',
                                 bio: actor.bio || 'Actor information from TMDB',
                                 movies: []
                             });
                         }
                         
                         // Add movie to actor's filmography
                         if (actorMap.has(actor.name)) {
                             const actorData = actorMap.get(actor.name);
                             if (!actorData.movies.some(m => m.id === content.id)) {
                                 actorData.movies.push({
                                     id: content.id,
                                     title: content.title,
                                     image: content.image,
                                     year: content.year
                                 });
                             }
                         }
                     });
                 }
             });
             
             return Array.from(actorMap.values());
         }

         function generateGenresFromContent() {
             const genreMap = new Map();
             
             // Process both slides and featuredMovies to ensure all genres are captured
             const allContent = [
                 ...(currentData.home.slides || []).map(slide => slide.poster || slide),
                 ...(currentData.home.featuredMovies || [])
             ];
             
             allContent.forEach(content => {
                 if (content && content.genres && Array.isArray(content.genres)) {
                     content.genres.forEach(genre => {
                         const genreTitle = genre.title || genre.name;
                         if (genreTitle && !genreMap.has(genreTitle)) {
                             genreMap.set(genreTitle, {
                                 id: genre.id || nextId++,
                                 title: genreTitle,
                                 posters: []
                             });
                         }
                         
                         // Add content to genre's posters
                         if (genreMap.has(genreTitle)) {
                             const genreData = genreMap.get(genreTitle);
                             if (!genreData.posters.some(p => p.id === content.id)) {
                                 genreData.posters.push({
                                     id: content.id,
                                     title: content.title,
                                     type: content.type,
                                     label: content.label,
                                     sublabel: content.sublabel,
                                     imdb: content.imdb,
                                     downloadas: content.downloadas,
                                     comment: content.comment,
                                     playas: content.playas,
                                     description: content.description,
                                     classification: content.classification,
                                     year: content.year,
                                     duration: content.duration,
                                     rating: content.rating,
                                     image: content.image,
                                     cover: content.cover,
                                     genres: content.genres,
                                     actors: content.actors,
                                     views: content.views,
                                     created_at: content.created_at,
                                     sources: content.sources,
                                     trailer: content.trailer,
                                     subtitles: content.subtitles,
                                     ...(content.type === 'series' && { seasons: content.seasons })
                                 });
                             }
                         }
                     });
                 }
             });
             
             return Array.from(genreMap.values());
         }

        // Manual input functions
        function toggleManualFields() {
            const type = document.getElementById('manual-type').value;
            const seriesFields = document.getElementById('series-fields');
            
            if (type === 'series') {
                seriesFields.style.display = 'block';
            } else {
                seriesFields.style.display = 'none';
            }
        }

        function addServer(containerId) {
            const container = document.getElementById(containerId);
            const serverItem = document.createElement('div');
            serverItem.className = 'server-item';
            
            // Determine placeholder based on container
            const isSeries = containerId === 'series-servers';
            const urlPlaceholder = isSeries ? 
                'Video URL Template (use {season} {episode})' : 
                'Video URL';
            
            serverItem.innerHTML = `
                <input type="text" placeholder="Server Name" class="server-name">
                <input type="url" placeholder="${urlPlaceholder}" class="server-url">
                <button class="paste-btn" onclick="pasteFromClipboard(this)">📋 Paste</button>
                <button class="btn btn-danger btn-small" onclick="removeServer(this)">Remove</button>
            `;
            container.appendChild(serverItem);
        }

        function addManualSource() {
            const container = document.getElementById('manual-sources');
            const sourceItem = document.createElement('div');
            sourceItem.className = 'server-item';
            sourceItem.innerHTML = `
                <input type="text" placeholder="Source Name" class="source-name">
                <input type="url" placeholder="Video URL" class="source-url">
                <select class="source-type">
                    <option value="video">Direct Video</option>
                    <option value="embed">Embedded</option>
                    <option value="youtube">YouTube</option>
                    <option value="live">Live Stream</option>
                </select>
                <select class="source-quality">
                    <option value="1080p">1080p</option>
                    <option value="720p">720p</option>
                    <option value="480p">480p</option>
                    <option value="Auto">Auto</option>
                </select>
                <button class="paste-btn" onclick="pasteFromClipboard(this)">📋 Paste</button>
                <button class="btn btn-danger btn-small" onclick="removeServer(this)">Remove</button>
            `;
            container.appendChild(sourceItem);
        }

        function removeServer(button) {
            button.parentElement.remove();
        }

        // Paste functionality
        async function pasteFromClipboard(button) {
            try {
                const text = await navigator.clipboard.readText();
                const serverItem = button.closest('.server-item');
                const urlInput = serverItem.querySelector('input[type="url"], .server-url, .source-url');
                
                if (urlInput) {
                    urlInput.value = text;
                    urlInput.focus();
                    showStatus('success', 'URL pasted successfully!');
                }
            } catch (error) {
                showStatus('error', 'Failed to paste from clipboard. Please paste manually.');
                console.error('Paste error:', error);
            }
        }

        async function addManualContent() {
            const type = document.getElementById('manual-type').value;
            const title = document.getElementById('manual-title').value.trim();
            const subcategory = document.getElementById('manual-subcategory').value;
            const country = document.getElementById('manual-country').value.trim();
            
            if (!title) {
                showStatus('warning', 'Please enter a title');
                return;
            }

            // Get servers
            const sourceInputs = document.querySelectorAll('#manual-sources .server-item');
            const servers = [];
            
            sourceInputs.forEach(item => {
                const name = item.querySelector('.source-name').value.trim();
                const url = item.querySelector('.source-url').value.trim();
                
                if (name && url) {
                    servers.push({
                        name: name,
                        url: url
                    });
                }
            });

            if (servers.length === 0) {
                showStatus('warning', 'Please add at least one server');
                return;
            }

            // Create entry object matching JSON structure
            const entry = {
                Title: title,
                SubCategory: subcategory,
                Country: country,
                Description: document.getElementById('manual-description').value || 'No description available',
                Poster: document.getElementById('manual-image').value || '',
                Thumbnail: document.getElementById('manual-image').value || '',
                Rating: parseInt(document.getElementById('manual-rating').value) || 0,
                Servers: servers
            };

            // Add additional fields based on type
            if (type === 'movie' || type === 'series') {
                entry.Year = parseInt(document.getElementById('manual-year').value) || new Date().getFullYear();
            }
            
            if (type === 'movie') {
                entry.Duration = "2:00:00"; // Default duration
            }
            
            if (type === 'series') {
                entry.Seasons = []; // Will be populated when seasons are added
            }

            // Find the appropriate category and add the entry
            let mainCategory = '';
            if (type === 'movie') mainCategory = 'Movies';
            else if (type === 'series') mainCategory = 'TV Series';
            else if (type === 'live') mainCategory = 'Live TV';

            const category = currentData.Categories.find(cat => cat.MainCategory === mainCategory);
            if (category) {
                // Add subcategory if it doesn't exist
                if (!category.SubCategories.includes(subcategory)) {
                    category.SubCategories.push(subcategory);
                }
                
                category.Entries.push(entry);
            } else {
                // Create new category if it doesn't exist
                currentData.Categories.push({
                    MainCategory: mainCategory,
                    SubCategories: [subcategory],
                    Entries: [entry]
                });
            }

            await saveData();
            updateDataStats();
            updatePreview();
            showStatus('success', `${title} added to ${mainCategory} successfully!`);
            
            // Clear form
            document.getElementById('manual-title').value = '';
            document.getElementById('manual-description').value = '';
            document.getElementById('manual-image').value = '';
            document.getElementById('manual-year').value = '';
            document.getElementById('manual-rating').value = '';
            document.getElementById('manual-country').value = '';
            
            // Reset sources to one empty item
            document.getElementById('manual-sources').innerHTML = `
                <div class="server-item">
                    <input type="text" placeholder="Source Name" class="source-name">
                    <input type="url" placeholder="Video URL" class="source-url">
                    <select class="source-type">
                        <option value="video">Direct Video</option>
                        <option value="embed">Embedded</option>
                        <option value="youtube">YouTube</option>
                        <option value="live">Live Stream</option>
                    </select>
                    <select class="source-quality">
                        <option value="1080p">1080p</option>
                        <option value="720p">720p</option>
                        <option value="480p">480p</option>
                        <option value="Auto">Auto</option>
                    </select>
                    <button class="paste-btn" onclick="pasteFromClipboard(this)">📋 Paste</button>
                    <button class="btn btn-danger btn-small" onclick="removeServer(this)">Remove</button>
                </div>
            `;
        }

        // Bulk operations
        async function bulkGenerate() {
            const type = document.getElementById('bulk-type').value;
            const year = document.getElementById('bulk-year').value;
            const pages = parseInt(document.getElementById('bulk-pages').value);
            const skipDuplicates = document.getElementById('bulk-skip-duplicates').checked;
            
            showLoading('bulk-loading', true);
            
            let generated = 0;
            let skipped = 0;
            
            for (let page = 1; page <= pages; page++) {
                const results = await fetchTMDB(`/discover/${type}`, {
                    primary_release_year: type === 'movie' ? year : undefined,
                    first_air_date_year: type === 'tv' ? year : undefined,
                    page: page,
                    sort_by: 'popularity.desc'
                });
                
                if (!results?.results) break;
                
                for (const item of results.results) {
                    // Check for duplicates
                    if (skipDuplicates && isDuplicate(item.id, type)) {
                        skipped++;
                        continue;
                    }
                    
                    try {
                        if (type === 'movie') {
                            await generateMovie(item.id);
                        } else {
                            await generateSeries(item.id);
                        }
                        generated++;
                    } catch (error) {
                        console.error(`Error generating ${type} ${item.id}:`, error);
                    }
                }
                
                // Update progress
                const progress = (page / pages) * 100;
                document.getElementById('bulk-progress').style.width = `${progress}%`;
                document.getElementById('bulk-status').innerHTML = `
                    <div class="status info">
                        Page ${page}/${pages} - Generated: ${generated}, Skipped: ${skipped}
                    </div>
                `;
                
                // Small delay to prevent API rate limiting
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            
                         showLoading('bulk-loading', false);
             updateDataStats();
             updatePreview();
             showStatus('success', `Bulk generation complete! Generated: ${generated} items with multi-server sources (VidSrc + VidJoy) matching existing app structure, Skipped: ${skipped}`);
        }

        async function generateByGenre() {
            const genreId = document.getElementById('genre-select').value;
            const count = parseInt(document.getElementById('genre-count').value);
            
            const results = await fetchTMDB('/discover/movie', {
                with_genres: genreId,
                sort_by: 'popularity.desc',
                page: 1
            });
            
            if (!results?.results) {
                showStatus('error', 'Failed to fetch genre data');
                return;
            }
            
            let generated = 0;
            
            for (const movie of results.results.slice(0, count)) {
                try {
                    if (!isDuplicate(movie.id, 'movie')) {
                        await generateMovie(movie.id);
                        generated++;
                    }
                } catch (error) {
                    console.error(`Error generating movie ${movie.id}:`, error);
                }
            }
            
            updateDataStats();
            updatePreview();
            showStatus('success', `Generated ${generated} movies from selected genre!`);
        }

        function isDuplicate(title, type) {
            const categoryName = type === 'movie' ? 'Movies' : 'TV Series';
            const category = currentData.Categories.find(cat => cat.MainCategory === categoryName);
            if (!category) return false;
            
            return category.Entries.some(entry => 
                entry.Title.toLowerCase() === title.toLowerCase()
            );
        }

        // Data management functions
        let importCancelled = false;
        let importStartTime = 0;
        
        function importData() {
            const fileInput = document.getElementById('import-file');
            const file = fileInput.files[0];
            
            if (!file) {
                showStatus('warning', 'Please select a file to import');
                return;
            }
            
            // Reset cancellation flag
            importCancelled = false;
            importStartTime = Date.now();
            
            // Show progress section and loading
            document.getElementById('import-progress-section').style.display = 'block';
            document.getElementById('cancel-import-btn').style.display = 'inline-block';
            showLoading('import-loading', true);
            
            // Update initial progress
            updateImportProgress(0, 0, 'Reading file...', '-');
            
            const reader = new FileReader();
            
            reader.onprogress = function(e) {
                if (e.lengthComputable && !importCancelled) {
                    const percentLoaded = Math.round((e.loaded / e.total) * 30); // File reading is 30% of total
                    updateImportProgress(percentLoaded, 0, `Reading file... ${Math.round(e.loaded / 1024 / 1024 * 10) / 10}MB / ${Math.round(e.total / 1024 / 1024 * 10) / 10}MB`, 'Loading file');
                }
            };
            
            reader.onload = function(e) {
                if (importCancelled) return;
                
                try {
                    updateImportProgress(30, 0, 'Parsing JSON data...', 'Validating');
                    
                    const jsonText = e.target.result;
                    console.log('📄 File loaded, size:', (jsonText.length / 1024 / 1024).toFixed(1), 'MB');
                    
                    const importedData = JSON.parse(jsonText);
                    console.log('✅ JSON parsed successfully');
                    
                    // Validate data structure for Categories format
                    if (!importedData.Categories || !Array.isArray(importedData.Categories)) {
                        console.error('❌ Invalid data structure:', {
                            hasCategories: !!importedData.Categories,
                            categoriesType: typeof importedData.Categories,
                            isArray: Array.isArray(importedData.Categories),
                            keys: Object.keys(importedData).slice(0, 10)
                        });
                        throw new Error(`Invalid data format - expected Categories array. Found: ${typeof importedData.Categories}`);
                    }
                    
                    updateImportProgress(40, 0, 'Validating data structure...', 'Validating');
                    console.log('📊 Found', importedData.Categories.length, 'categories');
                    
                    // Count total entries for progress tracking
                    let totalEntries = 0;
                    importedData.Categories.forEach((category, index) => {
                        if (!category.MainCategory || !Array.isArray(category.SubCategories) || !Array.isArray(category.Entries)) {
                            console.error(`❌ Invalid category structure at index ${index}:`, {
                                mainCategory: category.MainCategory,
                                hasSubCategories: !!category.SubCategories,
                                subCategoriesType: typeof category.SubCategories,
                                hasEntries: !!category.Entries,
                                entriesType: typeof category.Entries
                            });
                            throw new Error(`Invalid category structure at index ${index}: ${category.MainCategory || 'Unknown'}`);
                        }
                        totalEntries += category.Entries.length;
                        console.log(`📂 Category "${category.MainCategory}": ${category.Entries.length} entries`);
                    });
                    
                    updateImportProgress(50, 0, `Found ${totalEntries.toLocaleString()} entries in ${importedData.Categories.length} categories`, 'Processing');
                    console.log('🎯 Total entries to process:', totalEntries);
                    
                    // Process data with progress tracking
                    processImportData(importedData, totalEntries);
                    
                } catch (error) {
                    console.error('💥 Import error:', error);
                    hideImportProgress();
                    
                    let errorMessage = error.message;
                    if (error instanceof SyntaxError) {
                        errorMessage = `JSON Syntax Error: ${error.message}. Check the console for details.`;
                    }
                    
                    showStatus('error', `Import failed: ${errorMessage}`);
                    showLoading('import-loading', false);
                }
            };
            
            reader.onerror = function() {
                hideImportProgress();
                showStatus('error', 'Failed to read file');
                showLoading('import-loading', false);
            };
            
            reader.readAsText(file);
        }
        
        async function processImportData(importedData, totalEntries) {
            let processedEntries = 0;
            const batchSize = 100; // Process in batches to avoid blocking UI
            const startTime = Date.now();
            
            // Update total count
            document.getElementById('import-total').textContent = totalEntries.toLocaleString();
            
            try {
                for (let catIndex = 0; catIndex < importedData.Categories.length; catIndex++) {
                    if (importCancelled) {
                        showStatus('warning', 'Import cancelled by user');
                        return;
                    }
                    
                    const category = importedData.Categories[catIndex];
                    updateImportProgress(
                        50 + Math.round((processedEntries / totalEntries) * 50),
                        processedEntries,
                        `Processing ${category.MainCategory}...`,
                        category.MainCategory
                    );
                    
                    // Process entries in batches
                    for (let i = 0; i < category.Entries.length; i += batchSize) {
                        if (importCancelled) {
                            showStatus('warning', 'Import cancelled by user');
                            return;
                        }
                        
                        const batch = category.Entries.slice(i, Math.min(i + batchSize, category.Entries.length));
                        
                        // Process batch (simulate processing time for large datasets)
                        await new Promise(resolve => {
                            setTimeout(() => {
                                processedEntries += batch.length;
                                
                                // Update progress
                                const progressPercent = 50 + Math.round((processedEntries / totalEntries) * 50);
                                const elapsed = Date.now() - startTime;
                                const speed = processedEntries / (elapsed / 1000);
                                const remaining = totalEntries - processedEntries;
                                const eta = remaining > 0 ? Math.round(remaining / speed) : 0;
                                
                                updateImportProgress(
                                    progressPercent,
                                    processedEntries,
                                    `Processing ${category.MainCategory}... (${processedEntries.toLocaleString()}/${totalEntries.toLocaleString()})`,
                                    category.MainCategory,
                                    speed,
                                    eta
                                );
                                
                                resolve();
                            }, 1); // Small delay to keep UI responsive
                        });
                    }
                }
                
                                 if (!importCancelled) {
                     try {
                         // Finalize import
                         updateImportProgress(95, processedEntries, 'Finalizing import...', 'Saving');
                         console.log('💾 Starting finalization process...');
                         
                         // Step 1: Assign data
                         console.log('📝 Assigning imported data...');
                         currentData = importedData;
                         console.log('✅ Data assigned successfully');
                         
                         // Step 2: Save to localStorage (this might fail with large data)
                         updateImportProgress(96, processedEntries, 'Saving to localStorage...', 'Saving');
                         console.log('💾 Saving to localStorage...');
                         
                         try {
                             saveData();
                             console.log('✅ Data saved to localStorage successfully');
                         } catch (saveError) {
                             console.error('⚠️ localStorage save failed:', saveError);
                             console.log('📊 Data size:', JSON.stringify(currentData).length, 'characters');
                             
                             // Try to save without localStorage for now
                             console.log('⚡ Continuing without localStorage save...');
                             showStatus('warning', 'Data imported but could not save to localStorage (data too large). Data is active in current session.');
                         }
                         
                         updateImportProgress(98, processedEntries, 'Updating interface...', 'UI Update');
                         
                         // Step 3: Update UI components
                         console.log('🔄 Updating UI components...');
                         
                         try {
                             console.log('📊 Updating data stats...');
                             updateDataStats();
                             console.log('✅ Data stats updated');
                         } catch (statsError) {
                             console.error('⚠️ Data stats update failed:', statsError);
                         }
                         
                         try {
                             console.log('👁️ Updating preview...');
                             updatePreview();
                             console.log('✅ Preview updated');
                         } catch (previewError) {
                             console.error('⚠️ Preview update failed:', previewError);
                         }
                         
                                                 try {
                            console.log('📋 Refreshing content checkboxes...');
                            refreshContentCheckboxes();
                            console.log('✅ Content checkboxes refreshed');
                        } catch (dropdownError) {
                            console.error('⚠️ Checkbox refresh failed:', dropdownError);
                        }
                         
                         updateImportProgress(100, processedEntries, 'Import completed successfully!', 'Complete');
                         console.log('✨ Import process completed successfully!');
                         
                         // Hide progress after a short delay
                         setTimeout(() => {
                             hideImportProgress();
                             showStatus('success', `Successfully imported ${processedEntries.toLocaleString()} entries from ${importedData.Categories.length} categories!`);
                         }, 2000);
                         
                     } catch (finalizationError) {
                         console.error('💥 Finalization error:', finalizationError);
                         hideImportProgress();
                         showStatus('error', `Import data processed but finalization failed: ${finalizationError.message}. Check console for details.`);
                     }
                 }
                
            } catch (error) {
                hideImportProgress();
                showStatus('error', `Import processing failed: ${error.message}`);
            }
            
            showLoading('import-loading', false);
        }
        
        function updateImportProgress(percent, processed, message, category, speed = 0, eta = 0) {
            // Update progress bar
            document.getElementById('import-progress-fill').style.width = `${percent}%`;
            
            // Update progress text
            document.getElementById('import-progress-text').textContent = `${percent}% - ${message}`;
            
            // Update stats
            document.getElementById('import-processed').textContent = processed.toLocaleString();
            document.getElementById('import-current-category').textContent = category;
            
            if (speed > 0) {
                document.getElementById('import-speed').textContent = Math.round(speed);
                
                if (eta > 0) {
                    const minutes = Math.floor(eta / 60);
                    const seconds = eta % 60;
                    document.getElementById('import-eta').textContent = 
                        minutes > 0 ? `${minutes}m ${seconds}s` : `${seconds}s`;
                } else {
                    document.getElementById('import-eta').textContent = 'Almost done!';
                }
            }
        }
        
        function cancelImport() {
            importCancelled = true;
            hideImportProgress();
            showLoading('import-loading', false);
            showStatus('warning', 'Import cancelled');
        }
        
        function hideImportProgress() {
            document.getElementById('import-progress-section').style.display = 'none';
            document.getElementById('cancel-import-btn').style.display = 'none';
        }
        
        // Chunked Import - Alternative approach for large files
        function importDataChunked() {
            const fileInput = document.getElementById('import-file');
            const file = fileInput.files[0];
            
            if (!file) {
                showStatus('warning', 'Please select a file to import');
                return;
            }
            
            // Reset cancellation flag
            importCancelled = false;
            importStartTime = Date.now();
            
            // Show progress section and loading
            document.getElementById('import-progress-section').style.display = 'block';
            document.getElementById('cancel-import-btn').style.display = 'inline-block';
            showLoading('import-chunked-loading', true);
            
            // Update initial progress
            updateImportProgress(0, 0, 'Reading file for chunked processing...', 'Loading');
            
            const reader = new FileReader();
            
            reader.onprogress = function(e) {
                if (e.lengthComputable && !importCancelled) {
                    const percentLoaded = Math.round((e.loaded / e.total) * 20); // File reading is 20% of total
                    updateImportProgress(percentLoaded, 0, `Reading file... ${Math.round(e.loaded / 1024 / 1024 * 10) / 10}MB / ${Math.round(e.total / 1024 / 1024 * 10) / 10}MB`, 'Loading file');
                }
            };
            
            reader.onload = function(e) {
                if (importCancelled) return;
                
                try {
                    updateImportProgress(20, 0, 'Parsing JSON data...', 'Parsing');
                    
                    const jsonText = e.target.result;
                    console.log('📄 File loaded for chunked processing, size:', (jsonText.length / 1024 / 1024).toFixed(1), 'MB');
                    
                    const importedData = JSON.parse(jsonText);
                    console.log('✅ JSON parsed successfully for chunked import');
                    
                    // Validate data structure
                    if (!importedData.Categories || !Array.isArray(importedData.Categories)) {
                        throw new Error(`Invalid data format - expected Categories array. Found: ${typeof importedData.Categories}`);
                    }
                    
                    updateImportProgress(30, 0, 'Preparing chunked processing...', 'Preparing');
                    
                    // Process with chunked approach
                    processImportDataChunked(importedData);
                    
                } catch (error) {
                    console.error('💥 Chunked import error:', error);
                    hideImportProgress();
                    showStatus('error', `Chunked import failed: ${error.message}`);
                    showLoading('import-chunked-loading', false);
                }
            };
            
            reader.onerror = function() {
                hideImportProgress();
                showStatus('error', 'Failed to read file');
                showLoading('import-chunked-loading', false);
            };
            
            reader.readAsText(file);
        }
        
        async function processImportDataChunked(importedData) {
            console.log('🔄 Starting chunked processing...');
            
            try {
                // Count total entries
                let totalEntries = 0;
                importedData.Categories.forEach(category => {
                    totalEntries += category.Entries.length;
                });
                
                console.log(`📊 Total entries to process: ${totalEntries.toLocaleString()}`);
                document.getElementById('import-total').textContent = totalEntries.toLocaleString();
                
                updateImportProgress(35, 0, `Processing ${totalEntries.toLocaleString()} entries in chunks...`, 'Processing');
                
                // Initialize empty structure
                const newData = {
                    Categories: importedData.Categories.map(cat => ({
                        MainCategory: cat.MainCategory,
                        SubCategories: [...cat.SubCategories],
                        Entries: []
                    }))
                };
                
                let processedEntries = 0;
                const chunkSize = 50; // Much smaller chunks to prevent crashes
                const startTime = Date.now();
                
                // Process each category
                for (let catIndex = 0; catIndex < importedData.Categories.length; catIndex++) {
                    if (importCancelled) {
                        showStatus('warning', 'Chunked import cancelled by user');
                        return;
                    }
                    
                    const category = importedData.Categories[catIndex];
                    const targetCategory = newData.Categories[catIndex];
                    
                    console.log(`📂 Processing category: ${category.MainCategory} (${category.Entries.length} entries)`);
                    
                    // Process entries in very small chunks
                    for (let i = 0; i < category.Entries.length; i += chunkSize) {
                        if (importCancelled) {
                            showStatus('warning', 'Chunked import cancelled by user');
                            return;
                        }
                        
                        const chunk = category.Entries.slice(i, Math.min(i + chunkSize, category.Entries.length));
                        
                        // Process chunk with longer delay to prevent crashes
                        await new Promise(resolve => {
                            setTimeout(() => {
                                // Add entries to target category
                                targetCategory.Entries.push(...chunk);
                                processedEntries += chunk.length;
                                
                                // Update progress
                                const progressPercent = 35 + Math.round((processedEntries / totalEntries) * 60); // 35-95%
                                const elapsed = Date.now() - startTime;
                                const speed = processedEntries / (elapsed / 1000);
                                const remaining = totalEntries - processedEntries;
                                const eta = remaining > 0 ? Math.round(remaining / speed) : 0;
                                
                                updateImportProgress(
                                    progressPercent,
                                    processedEntries,
                                    `Processing ${category.MainCategory}... (Chunk ${Math.ceil((i + chunkSize) / chunkSize)}/${Math.ceil(category.Entries.length / chunkSize)})`,
                                    category.MainCategory,
                                    speed,
                                    eta
                                );
                                
                                console.log(`✅ Processed chunk: ${processedEntries}/${totalEntries} entries`);
                                resolve();
                            }, 10); // Longer delay to prevent crashes
                        });
                        
                        // Additional safety: Force garbage collection hint
                        if (processedEntries % 200 === 0) {
                            await new Promise(resolve => setTimeout(resolve, 50));
                        }
                    }
                }
                
                if (!importCancelled) {
                    console.log('🎯 All entries processed, finalizing...');
                    await finalizeChunkedImport(newData, processedEntries);
                }
                
            } catch (error) {
                console.error('💥 Chunked processing error:', error);
                hideImportProgress();
                showStatus('error', `Chunked processing failed: ${error.message}`);
            }
            
            showLoading('import-chunked-loading', false);
        }
        
        async function finalizeChunkedImport(newData, processedEntries) {
            try {
                updateImportProgress(95, processedEntries, 'Finalizing chunked import...', 'Finalizing');
                console.log('💾 Starting chunked import finalization...');
                
                // Assign data
                currentData = newData;
                console.log('✅ Data assigned successfully');
                
                // Try to save (might fail due to size)
                updateImportProgress(96, processedEntries, 'Attempting to save...', 'Saving');
                try {
                    saveData();
                    console.log('✅ Data saved to localStorage');
                } catch (saveError) {
                    console.warn('⚠️ Could not save to localStorage:', saveError.message);
                    showStatus('warning', 'Data imported successfully but too large for browser storage. Will work in current session only.');
                }
                
                // Update UI components safely
                updateImportProgress(98, processedEntries, 'Updating interface...', 'UI Update');
                
                await new Promise(resolve => {
                    setTimeout(() => {
                        try {
                            updateDataStats();
                            console.log('✅ Data stats updated');
                        } catch (e) {
                            console.warn('⚠️ Data stats update failed:', e);
                        }
                        resolve();
                    }, 100);
                });
                
                await new Promise(resolve => {
                    setTimeout(() => {
                        try {
                            // Skip preview update for large datasets to prevent crashes
                            if (processedEntries < 5000) {
                                updatePreview();
                                console.log('✅ Preview updated');
                            } else {
                                console.log('⚠️ Skipping preview update (dataset too large)');
                            }
                        } catch (e) {
                            console.warn('⚠️ Preview update failed:', e);
                        }
                        resolve();
                    }, 100);
                });
                
                await new Promise(resolve => {
                    setTimeout(() => {
                        try {
                            refreshContentCheckboxes();
                            console.log('✅ Content checkboxes refreshed');
                        } catch (e) {
                            console.warn('⚠️ Checkbox refresh failed:', e);
                        }
                        resolve();
                    }, 100);
                });
                
                updateImportProgress(100, processedEntries, 'Chunked import completed!', 'Complete');
                console.log('🎉 Chunked import completed successfully!');
                
                setTimeout(() => {
                    hideImportProgress();
                    showStatus('success', `🚀 Successfully imported ${processedEntries.toLocaleString()} entries using chunked processing! Data is ready to use.`);
                }, 2000);
                
            } catch (error) {
                console.error('💥 Chunked finalization error:', error);
                hideImportProgress();
                showStatus('error', `Chunked import processed data but finalization failed: ${error.message}`);
            }
        }

                                 function exportData() {
            // Export the Categories structure directly
            const dataStr = JSON.stringify(currentData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            
            const link = document.createElement('a');
            link.href = URL.createObjectURL(dataBlob);
            link.download = `playlist-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            
            showStatus('success', 'Data exported successfully in Categories structure!');
        }

                 function exportSample() {
             const sampleMovie = {
                 id: 1,
                 title: "Sample Movie",
                 type: "movie",
                 label: "Action",
                 sublabel: "Released 2023",
                 imdb: "8.5",
                 downloadas: "sample-movie.mp4",
                 comment: true,
                 playas: "video",
                 description: "This is a sample movie entry showing the correct CineMax structure",
                 classification: "PG-13",
                 year: "2023",
                 duration: "2:30",
                 rating: 8.5,
                 image: "https://example.com/poster.jpg",
                 cover: "https://example.com/cover.jpg",
                 genres: [
                     {
                         id: 28,
                         title: "Action"
                     }
                 ],
                 sources: [
                     {
                         id: 1,
                         type: "embed",
                         title: "VidSrc Server 1080p",
                         quality: "1080p",
                         size: "Auto",
                         kind: "play",
                         premium: "false",
                         external: false,
                         url: "https://vidsrc.net/embed/movie/123"
                     },
                     {
                         id: 2,
                         type: "embed",
                         title: "VidJoy Server 1080p",
                         quality: "1080p", 
                         size: "Auto",
                         kind: "play",
                         premium: "false",
                         external: false,
                         url: "https://vidjoy.pro/embed/movie/123"
                     }
                 ],
                 trailer: {
                     id: 3,
                     type: "youtube",
                     title: "Sample Movie Trailer",
                     url: "https://www.youtube.com/watch?v=dQw4w9WgXcQ"
                 },
                 actors: [
                     {
                         id: 1,
                         name: "John Doe",
                         type: "actor",
                         role: "Lead Actor",
                         image: "https://example.com/actor.jpg",
                         bio: "Sample actor"
                     }
                 ],
                 subtitles: [],
                 views: 5000,
                 created_at: new Date().toISOString().split('T')[0]
             };

             const sampleData = {
                 api_info: {
                     version: "2.0",
                     description: "Sample CineMax API Format with Complete Structure",
                     last_updated: new Date().toISOString().split('T')[0],
                     total_movies: 1,
                     total_series: 0,
                     total_channels: 0
                 },
                 home: {
                     slides: [
                         {
                             id: 1,
                             title: "Sample Movie",
                             type: "movie",
                             image: "https://example.com/poster.jpg",
                             url: "movies/1",
                             poster: sampleMovie
                         }
                     ],
                     featuredMovies: [sampleMovie],
                     channels: []
                 },
                 // Root-level movies array for GenreActivity and other fragments
                 movies: [sampleMovie],
                 actors: [
                     {
                         id: 1,
                         name: "John Doe",
                         type: "actor",
                         role: "Lead Actor",
                         image: "https://example.com/actor.jpg",
                         born: "1980-01-01",
                         height: "6'0\"",
                         bio: "Sample actor biography",
                         movies: [
                             {
                                 id: 1,
                                 title: "Sample Movie",
                                 image: "https://example.com/poster.jpg",
                                 year: "2023"
                             }
                         ]
                     }
                 ],
                 genres: [
                     {
                         id: 28,
                         title: "Action",
                         posters: [sampleMovie]
                     }
                 ],
                 channels: []
             };
            
            const dataStr = JSON.stringify(sampleData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            
            const link = document.createElement('a');
            link.href = URL.createObjectURL(dataBlob);
            link.download = 'cinemax-sample-format.json';
            link.click();
            
            showStatus('success', 'Sample format exported!');
        }

        async function clearAllData() {
            if (confirm('Are you sure you want to clear all data? This cannot be undone.')) {
                currentData = {
                    Categories: [
                        {
                            MainCategory: "Live TV",
                            SubCategories: ["Entertainment"],
                            Entries: []
                        },
                        {
                            MainCategory: "Movies", 
                            SubCategories: ["Action", "Comedy", "Drama", "Horror", "Sci-Fi"],
                            Entries: []
                        },
                        {
                            MainCategory: "TV Series",
                            SubCategories: ["Anime", "Action", "Comedy", "Drama"],
                            Entries: []
                        }
                    ]
                };
                
                await saveData();
                updateDataStats();
                updatePreview();
                showStatus('success', 'All data cleared!');
            }
        }

        async function removeDuplicates() {
            let originalCount = 0;
            let removedCount = 0;
            
            // Remove duplicates from each category
            currentData.Categories.forEach(category => {
                originalCount += category.Entries.length;
                
                const seen = new Set();
                const originalEntries = [...category.Entries];
                category.Entries = category.Entries.filter(entry => {
                    const key = `${entry.Title}-${entry.Year || 'Unknown'}`;
                    if (seen.has(key)) {
                        return false;
                    }
                    seen.add(key);
                    return true;
                });
                
                removedCount += originalEntries.length - category.Entries.length;
            });
            
            await saveData();
            updateDataStats();
            updatePreview();
            showStatus('success', `Removed ${removedCount} duplicate items!`);
        }

        // Storage management functions
        async function migrateStorage() {
            if (!confirm('This will migrate your data between localStorage and IndexedDB. Continue?')) {
                return;
            }

            try {
                showStatus('info', 'Migrating storage...');
                
                if (useIndexedDB) {
                    // Migrate from IndexedDB to localStorage
                    const dataString = JSON.stringify(currentData);
                    if (dataString.length < 4 * 1024 * 1024) { // Less than 4MB
                        const compressed = compressData(currentData);
                        localStorage.setItem('playlist-data', compressed);
                        localStorage.setItem('playlist-data-compressed', 'true');
                        localStorage.removeItem('playlist-data-indexeddb');
                        useIndexedDB = false;
                        showStatus('success', 'Data migrated to localStorage with compression!');
                    } else {
                        showStatus('warning', 'Data too large for localStorage. Keeping in IndexedDB.');
                    }
                } else {
                    // Migrate from localStorage to IndexedDB
                    await saveToIndexedDB(currentData);
                    localStorage.removeItem('playlist-data');
                    localStorage.removeItem('playlist-data-compressed');
                    localStorage.setItem('playlist-data-indexeddb', 'true');
                    useIndexedDB = true;
                    showStatus('success', 'Data migrated to IndexedDB!');
                }
                
                updateDataStats();
            } catch (error) {
                console.error('Migration failed:', error);
                showStatus('error', 'Migration failed: ' + error.message);
            }
        }

        async function optimizeStorage() {
            try {
                showStatus('info', 'Optimizing storage...');
                
                // Remove empty entries and clean up data
                let optimized = 0;
                currentData.Categories.forEach(category => {
                    const originalLength = category.Entries.length;
                    category.Entries = category.Entries.filter(entry => {
                        // Remove entries without titles or servers
                        return entry.Title && entry.Title.trim() !== '' && 
                               entry.Servers && entry.Servers.length > 0;
                    });
                    optimized += originalLength - category.Entries.length;
                });
                
                // Save optimized data
                await saveData();
                updateDataStats();
                updatePreview();
                
                showStatus('success', `Storage optimized! Removed ${optimized} empty entries.`);
            } catch (error) {
                console.error('Optimization failed:', error);
                showStatus('error', 'Optimization failed: ' + error.message);
            }
        }

        // Preview and management functions
        function updatePreview() {
            const filter = document.getElementById('preview-filter')?.value || 'all';
            const container = document.getElementById('content-preview');
            
            if (!container) return;
            
            container.innerHTML = '';
            
            let items = [];
            
            // Collect items from all categories based on filter
            currentData.Categories.forEach(category => {
                category.Entries.forEach(entry => {
                    let itemType = '';
                    if (category.MainCategory === "Movies") itemType = 'movie';
                    else if (category.MainCategory === "TV Series") itemType = 'series';
                    else if (category.MainCategory === "Live TV") itemType = 'live';
                    
                    if (filter === 'all' || filter === itemType) {
                        items.push({
                            ...entry,
                            type: itemType,
                            category: category.MainCategory,
                            image: entry.Poster || entry.Thumbnail,
                            title: entry.Title,
                            description: entry.Description,
                            year: entry.Year,
                            rating: entry.Rating,
                            sources: entry.Servers || []
                        });
                    }
                });
            });
            
            items.forEach(item => {
                const div = document.createElement('div');
                div.className = 'preview-item';
                
                div.innerHTML = `
                    <img src="${item.image || 'https://via.placeholder.com/300x450?text=No+Image'}" 
                         alt="${item.title}" loading="lazy">
                    <div class="info">
                        <div class="title">${item.title}</div>
                        <div class="meta">${item.year || 'Unknown'} • ${item.type?.toUpperCase()} • Rating: ${item.rating || 'N/A'}</div>
                        <div class="meta">Category: ${item.category} • SubCategory: ${item.SubCategory || 'N/A'}</div>
                        <div class="meta">Servers: ${item.sources?.length || 0}</div>
                        <div style="margin-top: 10px;">
                            <button class="btn btn-secondary btn-small" onclick="editContent('${item.Title}', '${item.category}')">Edit</button>
                            <button class="btn btn-warning btn-small" onclick="addServerToContent('${item.Title}', '${item.category}')">Add Server</button>
                            <button class="btn btn-danger btn-small" onclick="deleteContent('${item.Title}', '${item.category}')">Delete</button>
                        </div>
                    </div>
                `;
                
                container.appendChild(div);
            });
        }

        function editContent(title, category) {
            // Find the content
            let content = null;
            let foundCategory = null;
            
            currentData.Categories.forEach(cat => {
                if (cat.MainCategory === category) {
                    const entry = cat.Entries.find(e => e.Title === title);
                    if (entry) {
                        content = entry;
                        foundCategory = cat;
                    }
                }
            });
            
            if (!content) {
                showStatus('error', 'Content not found');
                return;
            }
            
            // Show edit modal (simplified version)
            const modal = document.getElementById('edit-modal');
            if (!modal) {
                // Create modal if it doesn't exist
                const modalHTML = `
                    <div id="edit-modal" class="modal">
                        <div class="modal-content">
                            <span class="close" onclick="closeEditModal()">&times;</span>
                            <h2>Edit Content</h2>
                            <div id="edit-form"></div>
                            <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                                <button class="btn btn-primary" onclick="saveEdit()">Save Changes</button>
                                <button class="btn btn-secondary" onclick="exportData()">💾 Export as Backup</button>
                            </div>
                        </div>
                    </div>
                `;
                document.body.insertAdjacentHTML('beforeend', modalHTML);
            }
            
            const form = document.getElementById('edit-form');
            
            // Build servers HTML
            let serversHTML = '';
            if (content.Servers && content.Servers.length > 0) {
                content.Servers.forEach((server, index) => {
                    serversHTML += `
                        <div class="server-item">
                            <input type="text" placeholder="Server Name" class="edit-server-name" value="${server.name || ''}">
                            <input type="url" placeholder="Video URL" class="edit-server-url" value="${server.url || ''}">
                            <button class="paste-btn" onclick="pasteFromClipboard(this)">📋 Paste</button>
                            <button class="btn btn-danger btn-small" onclick="removeServer(this)">Remove</button>
                        </div>
                    `;
                });
            } else {
                serversHTML = `
                    <div class="server-item">
                        <input type="text" placeholder="Server Name" class="edit-server-name">
                        <input type="url" placeholder="Video URL" class="edit-server-url">
                        <button class="paste-btn" onclick="pasteFromClipboard(this)">📋 Paste</button>
                        <button class="btn btn-danger btn-small" onclick="removeServer(this)">Remove</button>
                    </div>
                `;
            }
            
            // Build seasons HTML for TV Series
            let seasonsHTML = '';
            if (content.Seasons && content.Seasons.length > 0) {
                content.Seasons.forEach((season, seasonIndex) => {
                    seasonsHTML += `
                        <div class="season-group">
                            <h4>Season ${season.Season}</h4>
                            ${season.Episodes.map((episode, episodeIndex) => `
                                <div class="episode-group">
                                    <h5>Episode ${episode.Episode}: ${episode.Title}</h5>
                                    <div class="episode-servers">
                                        ${episode.Servers && episode.Servers.length > 0 ? 
                                            episode.Servers.map(server => `
                                                <div class="server-item">
                                                    <input type="text" placeholder="Server Name" class="edit-episode-server-name" value="${server.name || ''}" data-season="${seasonIndex}" data-episode="${episodeIndex}">
                                                    <input type="url" placeholder="Video URL" class="edit-episode-server-url" value="${server.url || ''}" data-season="${seasonIndex}" data-episode="${episodeIndex}">
                                                    <button class="paste-btn" onclick="pasteFromClipboard(this)">📋 Paste</button>
                                                    <button class="btn btn-danger btn-small" onclick="removeServer(this)">Remove</button>
                                                </div>
                                            `).join('') : 
                                            `<div class="server-item">
                                                <input type="text" placeholder="Server Name" class="edit-episode-server-name" data-season="${seasonIndex}" data-episode="${episodeIndex}">
                                                <input type="url" placeholder="Video URL" class="edit-episode-server-url" data-season="${seasonIndex}" data-episode="${episodeIndex}">
                                                <button class="paste-btn" onclick="pasteFromClipboard(this)">📋 Paste</button>
                                                <button class="btn btn-danger btn-small" onclick="removeServer(this)">Remove</button>
                                            </div>`
                                        }
                                        <button class="btn btn-secondary btn-small" onclick="addEpisodeServer(${seasonIndex}, ${episodeIndex})">+ Add Server</button>
                                        <button class="btn btn-warning btn-small" onclick="addServerToEpisode('${content.Title}', ${seasonIndex}, ${episodeIndex})">Quick Add</button>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    `;
                });
            }
            
            form.innerHTML = `
                <div class="form-group">
                    <label>Title</label>
                    <input type="text" id="edit-title" value="${content.Title}">
                </div>
                <div class="form-group">
                    <label>Description</label>
                    <textarea id="edit-description" rows="4">${content.Description || ''}</textarea>
                </div>
                <div class="form-group">
                    <label>Year</label>
                    <input type="text" id="edit-year" value="${content.Year || ''}">
                </div>
                <div class="form-group">
                    <label>Rating</label>
                    <input type="number" id="edit-rating" min="0" max="10" step="0.1" value="${content.Rating || ''}">
                </div>
                <div class="form-group">
                    <label>Servers</label>
                    <div id="edit-servers" class="server-list">
                        ${serversHTML}
                    </div>
                    <button class="btn btn-secondary btn-small" onclick="addEditServer()">+ Add Server</button>
                </div>
                ${content.Seasons ? `
                <div class="form-group">
                    <label>Seasons & Episodes</label>
                    <div id="edit-seasons">
                        ${seasonsHTML}
                    </div>
                </div>
                ` : ''}
                <input type="hidden" id="edit-original-title" value="${title}">
                <input type="hidden" id="edit-category" value="${category}">
            `;
            
            document.getElementById('edit-modal').style.display = 'block';
        }

        function closeEditModal() {
            document.getElementById('edit-modal').style.display = 'none';
        }

        function addEditServer() {
            const container = document.getElementById('edit-servers');
            const serverItem = document.createElement('div');
            serverItem.className = 'server-item';
            serverItem.innerHTML = `
                <input type="text" placeholder="Server Name" class="edit-server-name">
                <input type="url" placeholder="Video URL" class="edit-server-url">
                <button class="paste-btn" onclick="pasteFromClipboard(this)">📋 Paste</button>
                <button class="btn btn-danger btn-small" onclick="removeServer(this)">Remove</button>
            `;
            container.appendChild(serverItem);
        }

        function addEpisodeServer(seasonIndex, episodeIndex) {
            const episodeGroup = document.querySelector(`[data-season="${seasonIndex}"][data-episode="${episodeIndex}"]`).closest('.episode-group');
            const serversContainer = episodeGroup.querySelector('.episode-servers');
            
            const serverItem = document.createElement('div');
            serverItem.className = 'server-item';
            serverItem.innerHTML = `
                <input type="text" placeholder="Server Name" class="edit-episode-server-name" data-season="${seasonIndex}" data-episode="${episodeIndex}">
                <input type="url" placeholder="Video URL" class="edit-episode-server-url" data-season="${seasonIndex}" data-episode="${episodeIndex}">
                <button class="paste-btn" onclick="pasteFromClipboard(this)">📋 Paste</button>
                <button class="btn btn-danger btn-small" onclick="removeServer(this)">Remove</button>
            `;
            serversContainer.appendChild(serverItem);
        }

        async function saveEdit() {
            const originalTitle = document.getElementById('edit-original-title').value;
            const category = document.getElementById('edit-category').value;
            const newTitle = document.getElementById('edit-title').value;
            const description = document.getElementById('edit-description').value;
            const year = document.getElementById('edit-year').value;
            const rating = parseInt(document.getElementById('edit-rating').value);
            
            // Find and update content
            currentData.Categories.forEach(cat => {
                if (cat.MainCategory === category) {
                    const entry = cat.Entries.find(e => e.Title === originalTitle);
                    if (entry) {
                        entry.Title = newTitle;
                        entry.Description = description;
                        if (year) entry.Year = parseInt(year);
                        entry.Rating = rating;
                        
                        // Update servers
                        const serverInputs = document.querySelectorAll('#edit-servers .server-item');
                        const servers = [];
                        serverInputs.forEach(item => {
                            const name = item.querySelector('.edit-server-name').value.trim();
                            const url = item.querySelector('.edit-server-url').value.trim();
                            if (name && url) {
                                servers.push({ name, url });
                            }
                        });
                        entry.Servers = servers;
                        
                        // Update episode servers for TV Series
                        if (entry.Seasons) {
                            entry.Seasons.forEach((season, seasonIndex) => {
                                season.Episodes.forEach((episode, episodeIndex) => {
                                    const episodeServers = [];
                                    const episodeServerInputs = document.querySelectorAll(`.edit-episode-server-name[data-season="${seasonIndex}"][data-episode="${episodeIndex}"]`);
                                    
                                    episodeServerInputs.forEach(input => {
                                        const serverItem = input.closest('.server-item');
                                        const name = input.value.trim();
                                        const url = serverItem.querySelector('.edit-episode-server-url').value.trim();
                                        if (name && url) {
                                            episodeServers.push({ name, url });
                                        }
                                    });
                                    
                                    episode.Servers = episodeServers;
                                });
                            });
                        }
                    }
                }
            });
            
            try {
                await saveData();
                updatePreview();
                closeEditModal();
                showStatus('success', 'Content updated successfully with server changes!');
            } catch (error) {
                console.error('Save failed:', error);
                showStatus('error', 'Failed to save changes: ' + error.message + '. Your changes are preserved in memory but not saved to storage.');
                // Keep the modal open so user can try again or export data
            }
        }

        function deleteContent(title, category) {
            if (confirm(`Are you sure you want to delete "${title}"?`)) {
                // Remove from the appropriate category
                currentData.Categories.forEach(cat => {
                    if (cat.MainCategory === category) {
                        cat.Entries = cat.Entries.filter(entry => entry.Title !== title);
                    }
                });
                
                saveData();
                updateDataStats();
                updatePreview();
                showStatus('success', 'Content deleted successfully!');
            }
        }

        function addServerToContent(title, category) {
            // Find the content
            let content = null;
            let foundCategory = null;
            
            currentData.Categories.forEach(cat => {
                if (cat.MainCategory === category) {
                    const entry = cat.Entries.find(e => e.Title === title);
                    if (entry) {
                        content = entry;
                        foundCategory = cat;
                    }
                }
            });
            
            if (!content) {
                showStatus('error', 'Content not found');
                return;
            }
            
            // Show quick add server modal
            const modal = document.getElementById('edit-modal');
            if (!modal) {
                const modalHTML = `
                    <div id="edit-modal" class="modal">
                        <div class="modal-content">
                            <span class="close" onclick="closeEditModal()">&times;</span>
                            <h2>Add Server to ${content.Title}</h2>
                            <div id="edit-form"></div>
                            <button class="btn btn-primary" onclick="saveQuickServer()">Add Server</button>
                        </div>
                    </div>
                `;
                document.body.insertAdjacentHTML('beforeend', modalHTML);
            }
            
            const form = document.getElementById('edit-form');
            form.innerHTML = `
                <div class="form-group">
                    <label>Server Name</label>
                    <input type="text" id="quick-server-name" placeholder="e.g., VidSrc Server 1080p">
                </div>
                <div class="form-group">
                    <label>Server URL</label>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <input type="url" id="quick-server-url" placeholder="https://..." style="flex: 1;">
                        <button class="paste-btn" onclick="pasteFromClipboard(this)">📋 Paste</button>
                    </div>
                </div>
                <input type="hidden" id="quick-content-title" value="${title}">
                <input type="hidden" id="quick-content-category" value="${category}">
            `;
            
            document.getElementById('edit-modal').style.display = 'block';
        }

        function saveQuickServer() {
            const title = document.getElementById('quick-content-title').value;
            const category = document.getElementById('quick-content-category').value;
            const serverName = document.getElementById('quick-server-name').value.trim();
            const serverUrl = document.getElementById('quick-server-url').value.trim();
            
            if (!serverName || !serverUrl) {
                showStatus('warning', 'Please enter both server name and URL');
                return;
            }
            
            // Find and update content
            currentData.Categories.forEach(cat => {
                if (cat.MainCategory === category) {
                    const entry = cat.Entries.find(e => e.Title === title);
                    if (entry) {
                        if (!entry.Servers) {
                            entry.Servers = [];
                        }
                        entry.Servers.push({ name: serverName, url: serverUrl });
                    }
                }
            });
            
            saveData();
            updatePreview();
            closeEditModal();
            showStatus('success', `Server "${serverName}" added to "${title}" successfully!`);
        }

        function addServerToEpisode(title, seasonIndex, episodeIndex) {
            // Find the content
            let content = null;
            
            currentData.Categories.forEach(cat => {
                if (cat.MainCategory === "TV Series") {
                    const entry = cat.Entries.find(e => e.Title === title);
                    if (entry) {
                        content = entry;
                    }
                }
            });
            
            if (!content || !content.Seasons || !content.Seasons[seasonIndex] || !content.Seasons[seasonIndex].Episodes[episodeIndex]) {
                showStatus('error', 'Episode not found');
                return;
            }
            
            const episode = content.Seasons[seasonIndex].Episodes[episodeIndex];
            
            // Show quick add server modal for episode
            const modal = document.getElementById('edit-modal');
            if (!modal) {
                const modalHTML = `
                    <div id="edit-modal" class="modal">
                        <div class="modal-content">
                            <span class="close" onclick="closeEditModal()">&times;</span>
                            <h2>Add Server to Episode</h2>
                            <div id="edit-form"></div>
                            <button class="btn btn-primary" onclick="saveQuickEpisodeServer()">Add Server</button>
                        </div>
                    </div>
                `;
                document.body.insertAdjacentHTML('beforeend', modalHTML);
            }
            
            const form = document.getElementById('edit-form');
            form.innerHTML = `
                <div class="form-group">
                    <label>Server Name</label>
                    <input type="text" id="quick-episode-server-name" placeholder="e.g., VidSrc Server 1080p">
                </div>
                <div class="form-group">
                    <label>Server URL</label>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <input type="url" id="quick-episode-server-url" placeholder="https://..." style="flex: 1;">
                        <button class="paste-btn" onclick="pasteFromClipboard(this)">📋 Paste</button>
                    </div>
                </div>
                <input type="hidden" id="quick-episode-title" value="${title}">
                <input type="hidden" id="quick-episode-season" value="${seasonIndex}">
                <input type="hidden" id="quick-episode-episode" value="${episodeIndex}">
            `;
            
            document.getElementById('edit-modal').style.display = 'block';
        }

        function saveQuickEpisodeServer() {
            const title = document.getElementById('quick-episode-title').value;
            const seasonIndex = parseInt(document.getElementById('quick-episode-season').value);
            const episodeIndex = parseInt(document.getElementById('quick-episode-episode').value);
            const serverName = document.getElementById('quick-episode-server-name').value.trim();
            const serverUrl = document.getElementById('quick-episode-server-url').value.trim();
            
            if (!serverName || !serverUrl) {
                showStatus('warning', 'Please enter both server name and URL');
                return;
            }
            
            // Find and update content
            currentData.Categories.forEach(cat => {
                if (cat.MainCategory === "TV Series") {
                    const entry = cat.Entries.find(e => e.Title === title);
                    if (entry && entry.Seasons && entry.Seasons[seasonIndex] && entry.Seasons[seasonIndex].Episodes[episodeIndex]) {
                        if (!entry.Seasons[seasonIndex].Episodes[episodeIndex].Servers) {
                            entry.Seasons[seasonIndex].Episodes[episodeIndex].Servers = [];
                        }
                        entry.Seasons[seasonIndex].Episodes[episodeIndex].Servers.push({ name: serverName, url: serverUrl });
                    }
                }
            });
            
            saveData();
            updatePreview();
            closeEditModal();
            showStatus('success', `Server "${serverName}" added to episode successfully!`);
        }

        // Utility functions
        function updateDataStats() {
            let movieCount = 0;
            let seriesCount = 0;
            let channelCount = 0;
            
            // Count entries in each category
            currentData.Categories.forEach(category => {
                if (category.MainCategory === "Movies") {
                    movieCount += category.Entries.length;
                } else if (category.MainCategory === "TV Series") {
                    seriesCount += category.Entries.length;
                } else if (category.MainCategory === "Live TV") {
                    channelCount += category.Entries.length;
                }
            });
            
            // Calculate data size
            const dataString = JSON.stringify(currentData);
            const dataSizeKB = (dataString.length / 1024).toFixed(1);
            const dataSizeMB = (dataString.length / 1024 / 1024).toFixed(2);
            const displaySize = dataSizeKB > 1024 ? `${dataSizeMB} MB` : `${dataSizeKB} KB`;
            
            // Update display
            if (document.getElementById('movie-count')) {
                document.getElementById('movie-count').textContent = movieCount;
                document.getElementById('series-count').textContent = seriesCount;
                document.getElementById('channel-count').textContent = channelCount;
                document.getElementById('total-count').textContent = movieCount + seriesCount + channelCount;
                
                // Update storage info
                if (document.getElementById('storage-type')) {
                    document.getElementById('storage-type').textContent = useIndexedDB ? 'IndexedDB' : 'localStorage';
                    document.getElementById('data-size').textContent = displaySize;
                    
                    const isCompressed = localStorage.getItem('playlist-data-compressed') === 'true';
                    document.getElementById('compression-status').textContent = isCompressed ? 'Enabled' : 'None';
                    
                    // Update storage info styling based on size
                    const storageInfo = document.getElementById('storage-info');
                    if (dataSizeKB > 5120) { // > 5MB
                        storageInfo.className = 'status warning';
                    } else if (dataSizeKB > 10240) { // > 10MB
                        storageInfo.className = 'status error';
                    } else {
                        storageInfo.className = 'status info';
                    }
                }
            }
        }

        function showStatus(type, message) {
            // Create or update status element
            let statusEl = document.getElementById('global-status');
            if (!statusEl) {
                statusEl = document.createElement('div');
                statusEl.id = 'global-status';
                statusEl.style.position = 'fixed';
                statusEl.style.top = '20px';
                statusEl.style.right = '20px';
                statusEl.style.zIndex = '9999';
                statusEl.style.maxWidth = '400px';
                document.body.appendChild(statusEl);
            }
            
            statusEl.innerHTML = `<div class="status ${type}">${message}</div>`;
            
            // Auto-hide after 5 seconds
            setTimeout(() => {
                if (statusEl.parentNode) {
                    statusEl.parentNode.removeChild(statusEl);
                }
            }, 5000);
        }

        function showLoading(elementId, show) {
            const element = document.getElementById(elementId);
            if (element) {
                element.style.display = show ? 'inline-block' : 'none';
            }
        }

                                 // Enhanced storage system with IndexedDB fallback and compression
        let useIndexedDB = false;
        let db = null;

        // Initialize IndexedDB
        async function initIndexedDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('PlaylistManager', 1);
                
                request.onerror = () => reject(request.error);
                request.onsuccess = () => {
                    db = request.result;
                    resolve(db);
                };
                
                request.onupgradeneeded = (event) => {
                    const database = event.target.result;
                    if (!database.objectStoreNames.contains('data')) {
                        database.createObjectStore('data', { keyPath: 'id' });
                    }
                };
            });
        }

        // Save data to IndexedDB
        async function saveToIndexedDB(data) {
            if (!db) {
                await initIndexedDB();
            }
            
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['data'], 'readwrite');
                const store = transaction.objectStore('data');
                const request = store.put({ id: 'playlist-data', data: data, timestamp: Date.now() });
                
                request.onerror = () => reject(request.error);
                request.onsuccess = () => resolve();
            });
        }

        // Load data from IndexedDB
        async function loadFromIndexedDB() {
            if (!db) {
                await initIndexedDB();
            }
            
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['data'], 'readonly');
                const store = transaction.objectStore('data');
                const request = store.get('playlist-data');
                
                request.onerror = () => reject(request.error);
                request.onsuccess = () => {
                    const result = request.result;
                    resolve(result ? result.data : null);
                };
            });
        }

        // Simple compression using LZ-string-like algorithm
        function compressData(data) {
            try {
                const jsonString = JSON.stringify(data);
                // Simple compression by removing whitespace and common patterns
                let compressed = jsonString
                    .replace(/\s+/g, '')
                    .replace(/"MainCategory"/g, '"MC"')
                    .replace(/"SubCategories"/g, '"SC"')
                    .replace(/"Entries"/g, '"E"')
                    .replace(/"Title"/g, '"T"')
                    .replace(/"Description"/g, '"D"')
                    .replace(/"Poster"/g, '"P"')
                    .replace(/"Thumbnail"/g, '"Th"')
                    .replace(/"Rating"/g, '"R"')
                    .replace(/"Year"/g, '"Y"')
                    .replace(/"Servers"/g, '"S"')
                    .replace(/"Seasons"/g, '"Se"')
                    .replace(/"Episodes"/g, '"Ep"')
                    .replace(/"Episode"/g, '"En"')
                    .replace(/"Season"/g, '"Sn"')
                    .replace(/"Duration"/g, '"Du"')
                    .replace(/"SubCategory"/g, '"SuC"')
                    .replace(/"Country"/g, '"Co"');
                
                return compressed;
            } catch (error) {
                console.warn('Compression failed, using original data:', error);
                return JSON.stringify(data);
            }
        }

        // Decompress data
        function decompressData(compressedString) {
            try {
                let decompressed = compressedString
                    .replace(/"MC"/g, '"MainCategory"')
                    .replace(/"SC"/g, '"SubCategories"')
                    .replace(/"E"/g, '"Entries"')
                    .replace(/"T"/g, '"Title"')
                    .replace(/"D"/g, '"Description"')
                    .replace(/"P"/g, '"Poster"')
                    .replace(/"Th"/g, '"Thumbnail"')
                    .replace(/"R"/g, '"Rating"')
                    .replace(/"Y"/g, '"Year"')
                    .replace(/"S"/g, '"Servers"')
                    .replace(/"Se"/g, '"Seasons"')
                    .replace(/"Ep"/g, '"Episodes"')
                    .replace(/"En"/g, '"Episode"')
                    .replace(/"Sn"/g, '"Season"')
                    .replace(/"Du"/g, '"Duration"')
                    .replace(/"SuC"/g, '"SubCategory"')
                    .replace(/"Co"/g, '"Country"');
                
                return JSON.parse(decompressed);
            } catch (error) {
                console.warn('Decompression failed, trying original parse:', error);
                return JSON.parse(compressedString);
            }
        }

        // Enhanced save function with multiple strategies
        async function saveData() {
            try {
                const dataString = JSON.stringify(currentData);
                const dataSizeMB = (dataString.length / 1024 / 1024).toFixed(2);
                console.log(`💾 Attempting to save ${dataSizeMB}MB of data`);
                
                // Strategy 1: Try localStorage with compression for smaller datasets
                if (dataString.length < 4 * 1024 * 1024) { // Less than 4MB
                    try {
                        const compressed = compressData(currentData);
                        const compressionRatio = ((dataString.length - compressed.length) / dataString.length * 100).toFixed(1);
                        console.log(`🗜️ Compression saved ${compressionRatio}% space`);
                        
                        // Test localStorage availability
                        const testKey = 'storage-test-' + Date.now();
                        localStorage.setItem(testKey, 'test');
                        localStorage.removeItem(testKey);
                        
                        localStorage.setItem('playlist-data', compressed);
                        localStorage.setItem('playlist-data-compressed', 'true');
                        console.log('✅ Data saved to localStorage with compression');
                        useIndexedDB = false;
                        return;
                    } catch (localStorageError) {
                        console.warn('⚠️ localStorage failed, trying IndexedDB:', localStorageError.message);
                    }
                }
                
                // Strategy 2: Use IndexedDB for large datasets
                console.log('📦 Using IndexedDB for large dataset...');
                await saveToIndexedDB(currentData);
                useIndexedDB = true;
                
                // Clear localStorage to free up space
                try {
                    localStorage.removeItem('playlist-data');
                    localStorage.removeItem('playlist-data-compressed');
                    localStorage.setItem('playlist-data-indexeddb', 'true');
                } catch (e) {
                    console.warn('Could not clear localStorage:', e);
                }
                
                console.log('✅ Data saved to IndexedDB successfully');
                showStatus('success', `Large dataset (${dataSizeMB}MB) saved to IndexedDB successfully!`);
                
            } catch (error) {
                console.error('💥 All storage methods failed:', error);
                
                let errorMessage = 'Failed to save data: ';
                if (error.name === 'QuotaExceededError') {
                    errorMessage += 'Storage quota exceeded. Try clearing browser data or use export feature.';
                } else if (error.message.includes('not available')) {
                    errorMessage += 'Storage not available. Data will only persist in current session.';
                } else {
                    errorMessage += error.message;
                }
                
                showStatus('error', errorMessage);
                throw new Error(errorMessage);
            }
        }

        async function loadSavedData() {
            try {
                // Check if data is stored in IndexedDB
                if (localStorage.getItem('playlist-data-indexeddb') === 'true') {
                    console.log('📦 Loading data from IndexedDB...');
                    try {
                        const data = await loadFromIndexedDB();
                        if (data && data.Categories && Array.isArray(data.Categories)) {
                            currentData = data;
                            useIndexedDB = true;
                            console.log('✅ Data loaded from IndexedDB successfully');
                            return;
                        }
                    } catch (indexedDBError) {
                        console.warn('⚠️ IndexedDB loading failed:', indexedDBError);
                        localStorage.removeItem('playlist-data-indexeddb');
                    }
                }
                
                // Try localStorage with compression check
                let saved = localStorage.getItem('playlist-data');
                if (saved) {
                    try {
                        let data;
                        
                        // Check if data is compressed
                        if (localStorage.getItem('playlist-data-compressed') === 'true') {
                            console.log('🗜️ Decompressing data from localStorage...');
                            data = decompressData(saved);
                        } else {
                            data = JSON.parse(saved);
                        }
                        
                        // Check if it's the new Categories format
                        if (data.Categories && Array.isArray(data.Categories)) {
                            currentData = data;
                            useIndexedDB = false;
                            console.log('✅ Data loaded from localStorage successfully');
                            return;
                        }
                    } catch (parseError) {
                        console.warn('⚠️ Failed to parse localStorage data:', parseError);
                        localStorage.removeItem('playlist-data');
                        localStorage.removeItem('playlist-data-compressed');
                    }
                }
                
                // Fallback to old cinemax-data format
                saved = localStorage.getItem('cinemax-data');
                if (saved) {
                    try {
                        const data = JSON.parse(saved);
                        console.log('🔄 Converting old format to Categories structure...');
                        // For now, just use the default structure
                        currentData = {
                            Categories: [
                                {
                                    MainCategory: "Live TV",
                                    SubCategories: ["Entertainment"],
                                    Entries: []
                                },
                                {
                                    MainCategory: "Movies", 
                                    SubCategories: ["Action", "Comedy", "Drama", "Horror", "Sci-Fi"],
                                    Entries: []
                                },
                                {
                                    MainCategory: "TV Series",
                                    SubCategories: ["Anime", "Action", "Comedy", "Drama"],
                                    Entries: []
                                }
                            ]
                        };
                        localStorage.removeItem('cinemax-data');
                        await saveData(); // Save in new format
                    } catch (error) {
                        console.error('Error converting old data:', error);
                    }
                }
                
            } catch (error) {
                console.error('Error loading saved data:', error);
                showStatus('warning', 'Could not load saved data. Starting with empty dataset.');
            }
        }

        // Close modal when clicking outside
        window.onclick = function(event) {
            const modal = document.getElementById('edit-modal');
            if (event.target === modal) {
                modal.style.display = 'none';
            }
        }

        // Auto-Embed Functions
        function getAutoEmbedConfig() {
            return {
                vidsrc: {
                    enabled: document.getElementById('auto-vidsrc').checked,
                    quality: document.getElementById('vidsrc-quality').value
                },
                vidjoy: {
                    enabled: document.getElementById('auto-vidjoy').checked,
                    quality: document.getElementById('vidjoy-quality').value
                },
                multiembed: {
                    enabled: document.getElementById('auto-multiembed').checked,
                    quality: document.getElementById('multiembed-quality').value
                }
            };
        }

        function generateEmbedSources(tmdbId, contentType = 'movie', seasonNum = null, episodeNum = null) {
            const config = getAutoEmbedConfig();
            const sources = [];

            if (config.vidsrc.enabled) {
                let url;
                if (contentType === 'tv' && seasonNum && episodeNum) {
                    url = `${VIDSRC_BASE}/tv/${tmdbId}/${seasonNum}/${episodeNum}`;
                } else {
                    url = `${VIDSRC_BASE}/${contentType}/${tmdbId}`;
                }
                
                sources.push({
                    name: `VidSrc ${config.vidsrc.quality}`,
                    subtitle1: "",
                    subtitle2: "",
                    url: url
                });
            }

            if (config.vidjoy.enabled) {
                let url;
                if (contentType === 'tv' && seasonNum && episodeNum) {
                    url = `${VIDJOY_BASE}/tv/${tmdbId}/${seasonNum}/${episodeNum}`;
                } else {
                    url = `${VIDJOY_BASE}/${contentType}/${tmdbId}`;
                }
                
                sources.push({
                    name: `VidJoy ${config.vidjoy.quality}`,
                    subtitle1: "",
                    subtitle2: "",
                    url: url
                });
            }

            if (config.multiembed.enabled) {
                let url;
                if (contentType === 'tv' && seasonNum && episodeNum) {
                    url = `${MULTIEMBED_BASE}?video_id=${tmdbId}&tmdb=1&s=${seasonNum}&e=${episodeNum}`;
                } else {
                    url = `${MULTIEMBED_BASE}?video_id=${tmdbId}&content_type=${contentType}`;
                }
                
                sources.push({
                    name: `MultiEmbed ${config.multiembed.quality}`,
                    subtitle1: "",
                    subtitle2: "",
                    url: url
                });
            }

            return sources;
        }

        function hasEmbedSources(entry) {
            if (!entry.Servers || !Array.isArray(entry.Servers)) return false;
            return entry.Servers.some(server => 
                server.url && (
                    server.url.includes('vidsrc.net/embed') ||
                    server.url.includes('vidjoy.pro/embed') ||
                    server.url.includes('multiembed.mov')
                ) ||
                server.name && (
                    server.name.includes('VidSrc') ||
                    server.name.includes('VidJoy') ||
                    server.name.includes('MultiEmbed')
                )
            );
        }

        function hasDirectLinksOnly(entry) {
            if (!entry.Servers || !Array.isArray(entry.Servers)) return false;
            return entry.Servers.every(server => 
                server.url && !server.url.includes('embed') && 
                !server.url.includes('vidsrc.net') && 
                !server.url.includes('vidjoy.pro') && 
                !server.url.includes('multiembed.mov')
            );
        }

        function applyAutoEmbedToContent(entries, filterType = 'all') {
            const config = getAutoEmbedConfig();
            let processed = 0;
            let added = 0;

            entries.forEach(entry => {
                // Apply filter
                if (filterType === 'no-embed' && hasEmbedSources(entry)) return;
                if (filterType === 'direct-only' && !hasDirectLinksOnly(entry)) return;

                processed++;
                
                // Get TMDB ID from entry
                const tmdbId = entry.TMDB_ID || entry.tmdb_id;
                if (!tmdbId) return;

                // Determine content type
                const contentType = entry.Type === 'series' || entry.type === 'series' ? 'tv' : 'movie';
                
                // Generate embed sources
                const embedSources = generateEmbedSources(tmdbId, contentType);
                
                // Add embed sources to existing servers
                if (!entry.Servers) entry.Servers = [];
                entry.Servers.push(...embedSources);
                
                added += embedSources.length;
            });

            return { processed, added };
        }

        function applyAutoEmbedToMovies() {
            const moviesCategory = currentData.Categories.find(c => c.MainCategory === "Movies");
            if (!moviesCategory) {
                showStatus('error', 'Movies category not found');
                return;
            }

            const filterType = document.getElementById('auto-embed-filter').value;
            const result = applyAutoEmbedToContent(moviesCategory.Entries, filterType);
            
            showStatus('success', `Applied auto-embed to ${result.processed} movies, added ${result.added} embed sources`);
            saveData();
            updateDataStats();
        }

        function applyAutoEmbedToSeries() {
            const seriesCategory = currentData.Categories.find(c => c.MainCategory === "TV Series");
            if (!seriesCategory) {
                showStatus('error', 'TV Series category not found');
                return;
            }

            const filterType = document.getElementById('auto-embed-filter').value;
            let totalProcessed = 0;
            let totalAdded = 0;

            seriesCategory.Entries.forEach(series => {
                if (series.Seasons && Array.isArray(series.Seasons)) {
                    series.Seasons.forEach(season => {
                        if (season.Episodes && Array.isArray(season.Episodes)) {
                            const result = applyAutoEmbedToContent(season.Episodes, filterType);
                            totalProcessed += result.processed;
                            totalAdded += result.added;
                        }
                    });
                }
            });

            showStatus('success', `Applied auto-embed to ${totalProcessed} episodes, added ${totalAdded} embed sources`);
            saveData();
            updateDataStats();
        }

        function applyAutoEmbedToAll() {
            const filterType = document.getElementById('auto-embed-filter').value;
            let totalProcessed = 0;
            let totalAdded = 0;

            currentData.Categories.forEach(category => {
                if (category.MainCategory === "Movies") {
                    const result = applyAutoEmbedToContent(category.Entries, filterType);
                    totalProcessed += result.processed;
                    totalAdded += result.added;
                } else if (category.MainCategory === "TV Series") {
                    category.Entries.forEach(series => {
                        if (series.Seasons && Array.isArray(series.Seasons)) {
                            series.Seasons.forEach(season => {
                                if (season.Episodes && Array.isArray(season.Episodes)) {
                                    const result = applyAutoEmbedToContent(season.Episodes, filterType);
                                    totalProcessed += result.processed;
                                    totalAdded += result.added;
                                }
                            });
                        }
                    });
                }
            });

            showStatus('success', `Applied auto-embed to ${totalProcessed} items, added ${totalAdded} embed sources`);
            saveData();
            updateDataStats();
        }

        function updateAutoEmbedStatus() {
            const statusEl = document.getElementById('auto-embed-status');
            const config = getAutoEmbedConfig();
            const enabledCount = [config.vidsrc.enabled, config.vidjoy.enabled, config.multiembed.enabled].filter(Boolean).length;
            
            if (enabledCount > 0) {
                statusEl.style.display = 'block';
                statusEl.className = 'status info';
                statusEl.textContent = `Auto-embed enabled for ${enabledCount} services (VidSrc: ${config.vidsrc.enabled ? 'ON' : 'OFF'}, VidJoy: ${config.vidjoy.enabled ? 'ON' : 'OFF'}, MultiEmbed: ${config.multiembed.enabled ? 'ON' : 'OFF'})`;
            } else {
                statusEl.style.display = 'none';
            }
        }

        // Global variables for checkbox functionality
        window.selectedContent = new Map(); // Store selected content with TMDB search results
        window.contentGroups = { movies: [], series: [] };
        const MAX_SELECTIONS = 10;

        function refreshContentCheckboxes() {
            const container = document.getElementById('content-checkbox-list');
            container.innerHTML = '';
            
            // Clear previous selections
            window.selectedContent.clear();
            updateSelectionCounter();
            
            // Group movies and series
            let movieGroups = {};
            let seriesGroups = {};
            
            currentData.Categories.forEach(category => {
                if (category.MainCategory === "Movies") {
                    category.Entries.forEach((movie, movieIndex) => {
                        if (!hasEmbedSources(movie)) {
                            if (!movieGroups[movie.Title]) {
                                movieGroups[movie.Title] = {
                                    type: 'movie',
                                    category: 'Movies',
                                    title: movie.Title,
                                    entries: []
                                };
                            }
                            movieGroups[movie.Title].entries.push({
                                index: movieIndex,
                                entry: movie
                            });
                        }
                    });
                } else if (category.MainCategory === "TV Series") {
                    category.Entries.forEach((series, seriesIndex) => {
                        let episodesWithoutEmbed = [];
                        
                        if (series.Seasons && Array.isArray(series.Seasons)) {
                            series.Seasons.forEach((season, seasonIndex) => {
                                if (season.Episodes && Array.isArray(season.Episodes)) {
                                    season.Episodes.forEach((episode, episodeIndex) => {
                                        if (!hasEmbedSources(episode)) {
                                            episodesWithoutEmbed.push({
                                                seriesIndex: seriesIndex,
                                                seasonIndex: seasonIndex,
                                                episodeIndex: episodeIndex,
                                                entry: episode,
                                                season: season.Season,
                                                episode: episode.Episode
                                            });
                                        }
                                    });
                                }
                            });
                        }
                        
                        if (episodesWithoutEmbed.length > 0) {
                            seriesGroups[series.Title] = {
                                type: 'series',
                                category: 'TV Series',
                                title: series.Title,
                                episodes: episodesWithoutEmbed
                            };
                        }
                    });
                }
            });
            
            // Create checkboxes for movies
            Object.values(movieGroups).forEach((group, index) => {
                const checkboxItem = createCheckboxItem(`movie_${index}`, group.title, 'Movies', group.entries.length);
                container.appendChild(checkboxItem);
            });
            
            // Create checkboxes for series
            Object.values(seriesGroups).forEach((group, index) => {
                const checkboxItem = createCheckboxItem(`series_${index}`, group.title, 'TV Series', group.episodes.length);
                container.appendChild(checkboxItem);
            });
            
            // Store the grouped content for later use
            window.contentGroups = {
                movies: Object.values(movieGroups),
                series: Object.values(seriesGroups)
            };
            
            console.log('Content groups stored:', window.contentGroups);
            console.log('Movies found:', Object.values(movieGroups).length);
            console.log('Series found:', Object.values(seriesGroups).length);
            
            const totalItems = Object.values(movieGroups).length + Object.values(seriesGroups).length;
            const message = `Found ${totalItems} content items without embed links`;
            showStatus('info', message);
        }

        function createCheckboxItem(value, title, category, count) {
            const item = document.createElement('div');
            item.className = 'content-checkbox-item';
            item.dataset.value = value;
            
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = `checkbox_${value}`;
            checkbox.addEventListener('change', (e) => handleCheckboxChange(e, value, title, category));
            
            const label = document.createElement('label');
            label.className = 'content-checkbox-label';
            label.htmlFor = `checkbox_${value}`;
            label.textContent = `[${category}] ${title} (${count} item${count > 1 ? 's' : ''})`;
            
            const statusDiv = document.createElement('div');
            statusDiv.className = 'tmdb-status';
            statusDiv.id = `status_${value}`;
            
            item.appendChild(checkbox);
            item.appendChild(label);
            item.appendChild(statusDiv);
            
            return item;
        }

        async function handleCheckboxChange(event, value, title, category) {
            const checkbox = event.target;
            const item = checkbox.closest('.content-checkbox-item');
            const statusDiv = document.getElementById(`status_${value}`);
            
            if (checkbox.checked) {
                // Check if we've reached the maximum selection limit
                if (window.selectedContent.size >= MAX_SELECTIONS) {
                    checkbox.checked = false;
                    showStatus('warning', `Maximum ${MAX_SELECTIONS} items can be selected at once`);
                    return;
                }
                
                // Show searching status
                statusDiv.className = 'tmdb-status searching';
                statusDiv.innerHTML = '<div class="loading-spinner"></div><span>Searching TMDB...</span>';
                
                // Disable other checkboxes while searching
                disableUnselectedCheckboxes();
                
                try {
                    // Search for TMDB ID
                    const tmdbId = await searchTMDBForTitle(title, category);
                    
                    if (tmdbId) {
                        // TMDB ID found
                        statusDiv.className = 'tmdb-status found';
                        statusDiv.innerHTML = `<span>✅ TMDB ID: ${tmdbId}</span>`;
                        
                        // Store the selection
                        window.selectedContent.set(value, {
                            title: title,
                            category: category,
                            tmdbId: tmdbId,
                            contentData: getContentData(value)
                        });
                        
                        updateSelectionCounter();
                        updateBulkUpdateButton();
                        
                    } else {
                        // TMDB ID not found - uncheck and show manual input option
                        checkbox.checked = false;
                        statusDiv.className = 'tmdb-status not-found';
                        statusDiv.innerHTML = `
                            <span>❌ Not found</span>
                            <div class="manual-tmdb-input">
                                <input type="number" placeholder="TMDB ID" id="manual_${value}" min="1" onkeypress="if(event.key==='Enter') verifyManualTMDBId('${value}', '${title}', '${category}')">
                                <button class="btn btn-primary btn-verify" onclick="verifyManualTMDBId('${value}', '${title}', '${category}')">✓ Verify</button>
                            </div>
                        `;
                        
                        showStatus('warning', `TMDB ID not found for "${title}". You can enter the TMDB ID manually.`);
                    }
                } catch (error) {
                    // Error occurred - uncheck and show error
                    checkbox.checked = false;
                    statusDiv.className = 'tmdb-status not-found';
                    statusDiv.innerHTML = '<span>❌ Search failed</span>';
                    
                    showStatus('error', `Failed to search TMDB for "${title}": ${error.message}`);
                }
                
                // Re-enable checkboxes
                enableAllCheckboxes();
                
            } else {
                // Unchecked - remove from selection and clear status
                statusDiv.className = 'tmdb-status';
                statusDiv.innerHTML = '';
                window.selectedContent.delete(value);
                updateSelectionCounter();
                updateBulkUpdateButton();
            }
        }

        async function searchTMDBForTitle(title, category) {
            try {
                // Clean the title for better search results
                const cleanTitle = title.replace(/[^\w\s]/g, '').trim();
                const searchType = category === 'Movies' ? 'movie' : 'tv';
                
                console.log(`🔍 Searching TMDB for: "${cleanTitle}" (${searchType})`);
                
                const endpoint = `/search/${searchType}`;
                const results = await fetchTMDB(endpoint, { query: cleanTitle });
                
                if (results && results.results && results.results.length > 0) {
                    // Get the first result (most relevant)
                    const firstResult = results.results[0];
                    const resultTitle = firstResult.title || firstResult.name;
                    
                    console.log(`✅ Found TMDB match: "${resultTitle}" (ID: ${firstResult.id})`);
                    return firstResult.id;
                } else {
                    console.log(`❌ No TMDB results found for: "${cleanTitle}"`);
                    return null;
                }
            } catch (error) {
                console.error('TMDB search error:', error);
                throw error;
            }
        }

        function getContentData(value) {
            const [type, index] = value.split('_');
            return type === 'movie' ? 
                window.contentGroups.movies[parseInt(index)] : 
                window.contentGroups.series[parseInt(index)];
        }

        function disableUnselectedCheckboxes() {
            document.querySelectorAll('.content-checkbox-item').forEach(item => {
                const checkbox = item.querySelector('input[type="checkbox"]');
                if (!checkbox.checked) {
                    item.classList.add('disabled');
                    checkbox.disabled = true;
                }
            });
        }

        function enableAllCheckboxes() {
            document.querySelectorAll('.content-checkbox-item').forEach(item => {
                const checkbox = item.querySelector('input[type="checkbox"]');
                item.classList.remove('disabled');
                checkbox.disabled = false;
            });
        }

        function updateSelectionCounter() {
            const counter = document.getElementById('selection-counter');
            const count = window.selectedContent.size;
            counter.textContent = `Selected: ${count}/${MAX_SELECTIONS}`;
            
            if (count >= MAX_SELECTIONS) {
                counter.style.color = 'var(--warning)';
            } else {
                counter.style.color = 'var(--accent)';
            }
        }

        function updateBulkUpdateButton() {
            const button = document.getElementById('bulk-update-btn');
            const count = window.selectedContent.size;
            
            if (count > 0) {
                button.disabled = false;
                button.textContent = `🚀 Update ${count} Selected Item${count > 1 ? 's' : ''} with TMDB Metadata & Sources`;
            } else {
                button.disabled = true;
                button.textContent = '🚀 Update Selected Content with TMDB Metadata & Sources';
            }
        }

        function clearAllSelections() {
            // Uncheck all checkboxes
            document.querySelectorAll('.content-checkbox-item input[type="checkbox"]').forEach(checkbox => {
                checkbox.checked = false;
            });
            
            // Clear status indicators
            document.querySelectorAll('.tmdb-status').forEach(status => {
                status.className = 'tmdb-status';
                status.innerHTML = '';
            });
            
            // Clear selections
            window.selectedContent.clear();
            updateSelectionCounter();
            updateBulkUpdateButton();
            
            showStatus('info', 'All selections cleared');
        }

        async function verifyManualTMDBId(value, title, category) {
            const input = document.getElementById(`manual_${value}`);
            const tmdbId = parseInt(input.value);
            const statusDiv = document.getElementById(`status_${value}`);
            const checkbox = document.getElementById(`checkbox_${value}`);
            
            if (!tmdbId || tmdbId < 1) {
                showStatus('warning', 'Please enter a valid TMDB ID (positive number)');
                input.focus();
                return;
            }
            
            // Check if we've reached the maximum selection limit
            if (window.selectedContent.size >= MAX_SELECTIONS) {
                showStatus('warning', `Maximum ${MAX_SELECTIONS} items can be selected at once`);
                return;
            }
            
            // Show verifying status
            statusDiv.className = 'tmdb-status searching';
            statusDiv.innerHTML = '<div class="loading-spinner"></div><span>Verifying TMDB ID...</span>';
            
            try {
                // Verify the TMDB ID exists by fetching its details
                const searchType = category === 'Movies' ? 'movie' : 'tv';
                const tmdbData = await fetchTMDB(`/${searchType}/${tmdbId}`);
                
                if (tmdbData && (tmdbData.title || tmdbData.name)) {
                    // TMDB ID is valid
                    const tmdbTitle = tmdbData.title || tmdbData.name;
                    statusDiv.className = 'tmdb-status manual-entry';
                    statusDiv.innerHTML = `<span>✅ Manual: ${tmdbId} (${tmdbTitle})</span>`;
                    
                    // Check the checkbox and store the selection
                    checkbox.checked = true;
                    window.selectedContent.set(value, {
                        title: title,
                        category: category,
                        tmdbId: tmdbId,
                        contentData: getContentData(value),
                        isManualEntry: true,
                        verifiedTitle: tmdbTitle
                    });
                    
                    updateSelectionCounter();
                    updateBulkUpdateButton();
                    
                    showStatus('success', `✅ TMDB ID ${tmdbId} verified for "${title}" (matches: "${tmdbTitle}")`);
                    
                } else {
                    // TMDB ID doesn't exist
                    statusDiv.className = 'tmdb-status not-found';
                    statusDiv.innerHTML = `
                        <span>❌ Invalid ID</span>
                        <div class="manual-tmdb-input">
                            <input type="number" placeholder="TMDB ID" id="manual_${value}" min="1" value="${tmdbId}" onkeypress="if(event.key==='Enter') verifyManualTMDBId('${value}', '${title}', '${category}')">
                            <button class="btn btn-primary btn-verify" onclick="verifyManualTMDBId('${value}', '${title}', '${category}')">✓ Verify</button>
                        </div>
                    `;
                    
                    showStatus('error', `TMDB ID ${tmdbId} does not exist. Please check the ID and try again.`);
                }
                
            } catch (error) {
                // Error occurred during verification
                statusDiv.className = 'tmdb-status not-found';
                statusDiv.innerHTML = `
                    <span>❌ Verify failed</span>
                    <div class="manual-tmdb-input">
                        <input type="number" placeholder="TMDB ID" id="manual_${value}" min="1" value="${tmdbId}" onkeypress="if(event.key==='Enter') verifyManualTMDBId('${value}', '${title}', '${category}')">
                        <button class="btn btn-primary btn-verify" onclick="verifyManualTMDBId('${value}', '${title}', '${category}')">✓ Verify</button>
                    </div>
                `;
                
                showStatus('error', `Failed to verify TMDB ID ${tmdbId}: ${error.message}`);
            }
        }

        async function bulkUpdateSelectedContent() {
            if (window.selectedContent.size === 0) {
                showStatus('warning', 'No content selected for update');
                return;
            }

            const button = document.getElementById('bulk-update-btn');
            const progressBar = document.getElementById('bulk-update-progress');
            const progressFill = document.getElementById('bulk-update-progress-fill');
            const statusDiv = document.getElementById('bulk-update-status');
            
            // Disable button and show progress
            button.disabled = true;
            progressBar.style.display = 'block';
            statusDiv.style.display = 'block';
            statusDiv.className = 'status info';
            
            const totalItems = window.selectedContent.size;
            let processed = 0;
            let successful = 0;
            let failed = 0;
            
            statusDiv.textContent = `Processing 0/${totalItems} items...`;
            
            try {
                for (const [key, contentInfo] of window.selectedContent.entries()) {
                    try {
                        // Update progress
                        const progressPercent = (processed / totalItems) * 100;
                        progressFill.style.width = `${progressPercent}%`;
                        statusDiv.textContent = `Processing ${processed + 1}/${totalItems}: ${contentInfo.title} (updating metadata & sources)`;
                        
                        // Apply auto-embed to the content using the found TMDB ID
                        await applyAutoEmbedToContentGroup(contentInfo.contentData, contentInfo.tmdbId);
                        
                        successful++;
                        const entryType = contentInfo.isManualEntry ? 'Manual' : 'Auto';
                        const verifiedInfo = contentInfo.verifiedTitle ? ` → ${contentInfo.verifiedTitle}` : '';
                        console.log(`✅ Successfully updated: ${contentInfo.title} (${entryType} TMDB ID: ${contentInfo.tmdbId}${verifiedInfo})`);
                        
                    } catch (error) {
                        failed++;
                        console.error(`❌ Failed to update: ${contentInfo.title}`, error);
                    }
                    
                    processed++;
                    
                    // Small delay to prevent overwhelming the system
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                
                // Complete progress
                progressFill.style.width = '100%';
                
                // Show final status
                if (failed === 0) {
                    statusDiv.className = 'status success';
                    statusDiv.textContent = `✅ Successfully updated ${successful} items with TMDB metadata & auto-embed sources!`;
                    showStatus('success', `Bulk update completed! ${successful} items updated with full TMDB metadata and sources.`);
                } else {
                    statusDiv.className = 'status warning';
                    statusDiv.textContent = `⚠️ Update completed with ${successful} successful and ${failed} failed items.`;
                    showStatus('warning', `Bulk update completed with some errors. ${successful} successful, ${failed} failed.`);
                }
                
                // Clear selections and refresh
                clearAllSelections();
                await saveData();
                updateDataStats();
                updatePreview();
                
                // Hide progress after delay
                setTimeout(() => {
                    progressBar.style.display = 'none';
                    statusDiv.style.display = 'none';
                    button.disabled = false;
                }, 3000);
                
            } catch (error) {
                console.error('Bulk update error:', error);
                statusDiv.className = 'status error';
                statusDiv.textContent = `❌ Bulk update failed: ${error.message}`;
                showStatus('error', `Bulk update failed: ${error.message}`);
                
                // Re-enable button
                button.disabled = false;
                progressBar.style.display = 'none';
            }
        }

        async function applyAutoEmbedToContentGroup(contentGroup, tmdbId) {
            const config = getAutoEmbedConfig();
            
            if (contentGroup.type === 'movie') {
                // Fetch movie metadata from TMDB
                const movieData = await fetchTMDB(`/movie/${tmdbId}`);
                const credits = await fetchTMDB(`/movie/${tmdbId}/credits`);
                
                if (movieData) {
                    // Process movie entries
                    for (const movieEntry of contentGroup.entries) {
                        const movie = movieEntry.entry;
                        
                        // Update metadata from TMDB
                        await updateMovieMetadata(movie, movieData, credits);
                        
                        // Add auto-embed sources
                        const autoSources = generateEmbedSources(tmdbId, 'movie');
                        autoSources.forEach(source => {
                            movie.Servers = movie.Servers || [];
                            movie.Servers.push({
                                name: source.title,
                                url: source.url
                            });
                        });
                    }
                }
            } else if (contentGroup.type === 'series') {
                // Fetch series metadata from TMDB
                const seriesData = await fetchTMDB(`/tv/${tmdbId}`);
                const credits = await fetchTMDB(`/tv/${tmdbId}/credits`);
                
                if (seriesData) {
                    // Update series-level metadata first
                    const seriesTitle = contentGroup.title;
                    const seriesCategory = currentData.Categories.find(cat => cat.MainCategory === "TV Series");
                    const seriesEntry = seriesCategory?.Entries.find(entry => entry.Title === seriesTitle);
                    
                    if (seriesEntry) {
                        await updateSeriesMetadata(seriesEntry, seriesData, credits);
                    }
                    
                    // Process series episodes
                    const processedSeasons = new Set();
                    
                    for (const episodeInfo of contentGroup.episodes) {
                        const episode = episodeInfo.entry;
                        const seasonNum = episodeInfo.season;
                        const episodeNum = episodeInfo.episode;
                        
                        // Fetch season data if not already processed
                        if (!processedSeasons.has(seasonNum)) {
                            const seasonData = await fetchTMDB(`/tv/${tmdbId}/season/${seasonNum}`);
                            if (seasonData && seriesEntry) {
                                await updateSeasonMetadata(seriesEntry, seasonNum, seasonData);
                            }
                            processedSeasons.add(seasonNum);
                        }
                        
                        // Fetch episode-specific data
                        const episodeData = await fetchTMDB(`/tv/${tmdbId}/season/${seasonNum}/episode/${episodeNum}`);
                        if (episodeData) {
                            await updateEpisodeMetadata(episode, episodeData);
                        }
                        
                        // Add auto-embed sources
                        const autoSources = generateEmbedSources(tmdbId, 'tv', seasonNum, episodeNum);
                        autoSources.forEach(source => {
                            episode.Servers = episode.Servers || [];
                            episode.Servers.push({
                                name: source.title,
                                url: source.url
                            });
                        });
                    }
                }
            }
            
            console.log(`✅ Applied auto-embed sources and updated metadata for ${contentGroup.title} (TMDB ID: ${tmdbId})`);
        }

        async function updateMovieMetadata(movie, movieData, credits) {
            try {
                // Update basic metadata
                if (movieData.overview) movie.Description = movieData.overview;
                if (movieData.poster_path) {
                    movie.Poster = `${TMDB_IMAGE_BASE}${movieData.poster_path}`;
                    movie.Thumbnail = `${TMDB_IMAGE_BASE}${movieData.poster_path}`;
                }
                if (movieData.vote_average) movie.Rating = Math.round(movieData.vote_average);
                if (movieData.runtime) movie.Duration = formatDuration(movieData.runtime);
                if (movieData.release_date) movie.Year = parseInt(movieData.release_date.substring(0, 4));
                
                // Update country (production countries)
                if (movieData.production_countries && movieData.production_countries.length > 0) {
                    movie.Country = movieData.production_countries.map(c => c.name).join(', ');
                }
                
                // Update subcategory based on primary genre
                if (movieData.genres && movieData.genres.length > 0) {
                    const primaryGenre = movieData.genres[0].name;
                    movie.SubCategory = primaryGenre;
                    
                    // Update category subcategories list
                    const moviesCategory = currentData.Categories.find(cat => cat.MainCategory === "Movies");
                    if (moviesCategory && !moviesCategory.SubCategories.includes(primaryGenre)) {
                        moviesCategory.SubCategories.push(primaryGenre);
                    }
                }
                
                console.log(`📝 Updated movie metadata: ${movie.Title}`);
            } catch (error) {
                console.error(`⚠️ Error updating movie metadata for ${movie.Title}:`, error);
            }
        }

        async function updateSeriesMetadata(seriesEntry, seriesData, credits) {
            try {
                // Update basic metadata
                if (seriesData.overview) seriesEntry.Description = seriesData.overview;
                if (seriesData.poster_path) {
                    seriesEntry.Poster = `${TMDB_IMAGE_BASE}${seriesData.poster_path}`;
                    seriesEntry.Thumbnail = `${TMDB_IMAGE_BASE}${seriesData.poster_path}`;
                }
                if (seriesData.vote_average) seriesEntry.Rating = Math.round(seriesData.vote_average);
                if (seriesData.first_air_date) seriesEntry.Year = parseInt(seriesData.first_air_date.substring(0, 4));
                
                // Update country (origin countries)
                if (seriesData.origin_country && seriesData.origin_country.length > 0) {
                    seriesEntry.Country = seriesData.origin_country.join(', ');
                }
                
                // Update subcategory based on primary genre
                if (seriesData.genres && seriesData.genres.length > 0) {
                    const primaryGenre = seriesData.genres[0].name;
                    seriesEntry.SubCategory = primaryGenre;
                    
                    // Update category subcategories list
                    const seriesCategory = currentData.Categories.find(cat => cat.MainCategory === "TV Series");
                    if (seriesCategory && !seriesCategory.SubCategories.includes(primaryGenre)) {
                        seriesCategory.SubCategories.push(primaryGenre);
                    }
                }
                
                console.log(`📺 Updated series metadata: ${seriesEntry.Title}`);
            } catch (error) {
                console.error(`⚠️ Error updating series metadata for ${seriesEntry.Title}:`, error);
            }
        }

        async function updateSeasonMetadata(seriesEntry, seasonNum, seasonData) {
            try {
                if (!seriesEntry.Seasons) return;
                
                const season = seriesEntry.Seasons.find(s => s.Season === seasonNum);
                if (season && seasonData.poster_path) {
                    season.SeasonPoster = `${TMDB_IMAGE_BASE}${seasonData.poster_path}`;
                }
                
                console.log(`🎭 Updated season ${seasonNum} metadata for: ${seriesEntry.Title}`);
            } catch (error) {
                console.error(`⚠️ Error updating season ${seasonNum} metadata:`, error);
            }
        }

        async function updateEpisodeMetadata(episode, episodeData) {
            try {
                // Update episode metadata
                if (episodeData.name && episodeData.name !== `Episode ${episodeData.episode_number}`) {
                    episode.Title = episodeData.name;
                }
                if (episodeData.overview) episode.Description = episodeData.overview;
                if (episodeData.runtime) episode.Duration = formatDuration(episodeData.runtime);
                if (episodeData.still_path) {
                    episode.Thumbnail = `${TMDB_IMAGE_BASE}${episodeData.still_path}`;
                }
                
                console.log(`📝 Updated episode metadata: S${episodeData.season_number}E${episodeData.episode_number} - ${episode.Title}`);
            } catch (error) {
                console.error(`⚠️ Error updating episode metadata:`, error);
            }
        }
        
        function updateSelectedContentInfo() {
            const select = document.getElementById('auto-embed-content-select');
            const infoDiv = document.getElementById('selected-content-info');
            
            if (!select.value || !window.contentGroups) {
                infoDiv.style.display = 'none';
                return;
            }
            
            const [type, index] = select.value.split('_');
            const selectedGroup = type === 'movie' ? 
                window.contentGroups.movies[parseInt(index)] : 
                window.contentGroups.series[parseInt(index)];
            
            if (selectedGroup) {
                infoDiv.style.display = 'block';
                infoDiv.className = 'status info';
                
                let totalCurrentServers = 0;
                let totalEmbedServers = 0;
                
                if (selectedGroup.type === 'movie') {
                    selectedGroup.entries.forEach(item => {
                        const servers = item.entry.Servers || [];
                        totalCurrentServers += servers.length;
                        totalEmbedServers += servers.filter(s => 
                            s.url && (s.url.includes('vidsrc.net/embed') || 
                                     s.url.includes('vidjoy.pro/embed') || 
                                     s.url.includes('multiembed.mov'))
                        ).length;
                    });
                } else if (selectedGroup.type === 'series') {
                    selectedGroup.episodes.forEach(item => {
                        const servers = item.entry.Servers || [];
                        totalCurrentServers += servers.length;
                        totalEmbedServers += servers.filter(s => 
                            s.url && (s.url.includes('vidsrc.net/embed') || 
                                     s.url.includes('vidjoy.pro/embed') || 
                                     s.url.includes('multiembed.mov'))
                        ).length;
                    });
                }
                
                const embedSourcesToAdd = getAutoEmbedConfig().vidsrc.enabled + getAutoEmbedConfig().vidjoy.enabled + getAutoEmbedConfig().multiembed.enabled;
                const totalItems = selectedGroup.type === 'movie' ? selectedGroup.entries.length : selectedGroup.episodes.length;
                const totalEmbedSourcesToAdd = totalItems * embedSourcesToAdd;
                
                const tmdbIdInput = document.getElementById('selected-tmdb-id');
                const hasExistingTmdbId = selectedGroup.type === 'movie' ? 
                    selectedGroup.entries[0]?.entry.TMDB_ID || selectedGroup.entries[0]?.entry.tmdb_id :
                    selectedGroup.episodes[0]?.entry.TMDB_ID || selectedGroup.episodes[0]?.entry.tmdb_id;
                
                infoDiv.innerHTML = `
                    <strong>Selected:</strong> ${selectedGroup.title}<br>
                    <strong>Type:</strong> ${selectedGroup.type === 'movie' ? 'Movie' : 'TV Series'}<br>
                    <strong>Items:</strong> ${totalItems} ${selectedGroup.type === 'movie' ? 'movie(s)' : 'episode(s)'}<br>
                    <strong>Current Servers:</strong> ${totalCurrentServers}<br>
                    <strong>Embed Servers:</strong> ${totalEmbedServers}<br>
                    <strong>Will Add:</strong> ${totalEmbedSourcesToAdd} embed sources (${embedSourcesToAdd} per item)<br>
                    <strong>TMDB ID:</strong> ${hasExistingTmdbId ? hasExistingTmdbId : 'None'} ${tmdbIdInput.value ? `(Will use: ${tmdbIdInput.value})` : ''}
                `;
            }
        }
        
        async function applyAutoEmbedToSelected() {
            const select = document.getElementById('auto-embed-content-select');
            const tmdbIdInput = document.getElementById('selected-tmdb-id');
            
            if (!select.value || !window.contentGroups) {
                showStatus('warning', 'Please select content to apply auto-embed to');
                return;
            }
            
            const [type, index] = select.value.split('_');
            const selectedGroup = type === 'movie' ? 
                window.contentGroups.movies[parseInt(index)] : 
                window.contentGroups.series[parseInt(index)];
            
            if (!selectedGroup) {
                showStatus('error', 'Selected content not found');
                return;
            }
            
            // Get TMDB ID from input or existing entry
            let tmdbId = tmdbIdInput.value.trim();
            if (!tmdbId) {
                // Use existing TMDB ID from first item
                if (selectedGroup.type === 'movie') {
                    tmdbId = selectedGroup.entries[0]?.entry.TMDB_ID || selectedGroup.entries[0]?.entry.tmdb_id;
                } else {
                    tmdbId = selectedGroup.episodes[0]?.entry.TMDB_ID || selectedGroup.episodes[0]?.entry.tmdb_id;
                }
            }
            
            if (!tmdbId) {
                showStatus('error', 'No TMDB ID found. Please enter a TMDB ID or ensure content has TMDB ID.');
                return;
            }
            
            let processedItems = 0;
            let totalEmbedSourcesAdded = 0;
            let updatedInfo = false;
            
            try {
                if (selectedGroup.type === 'movie') {
                    // Fetch fresh movie data from TMDB if new ID provided
                    let movieData = null;
                    if (tmdbIdInput.value.trim()) {
                        showStatus('info', 'Fetching fresh data from TMDB...');
                        movieData = await fetchTMDB(`/movie/${tmdbId}`);
                        if (movieData) {
                            updatedInfo = true;
                        }
                    }
                    
                    // Process all movies with the same title
                    for (const item of selectedGroup.entries) {
                        // Update info if fresh data was fetched
                        if (movieData) {
                            item.entry.Title = movieData.title;
                            item.entry.Description = movieData.overview || item.entry.Description;
                            item.entry.Poster = movieData.poster_path ? `${TMDB_IMAGE_BASE}${movieData.poster_path}` : item.entry.Poster;
                            item.entry.Thumbnail = movieData.backdrop_path ? `${TMDB_IMAGE_BASE}${movieData.backdrop_path}` : item.entry.Thumbnail;
                            item.entry.Rating = Math.round(movieData.vote_average || item.entry.Rating);
                            item.entry.Year = parseInt(movieData.release_date?.substring(0, 4) || item.entry.Year);
                            item.entry.Duration = formatDuration(movieData.runtime) || item.entry.Duration;
                        }
                        
                        // Generate embed sources
                        
                        // Generate embed sources
                        const embedSources = generateEmbedSources(tmdbId, 'movie');
                        
                        // Preserve existing servers and add embed sources
                        if (!item.entry.Servers) item.entry.Servers = [];
                        item.entry.Servers.push(...embedSources);
                        
                        // Update the actual data structure
                        const moviesCategory = currentData.Categories.find(c => c.MainCategory === "Movies");
                        if (moviesCategory && moviesCategory.Entries[item.index]) {
                            moviesCategory.Entries[item.index] = item.entry;
                        }
                        
                        processedItems++;
                        totalEmbedSourcesAdded += embedSources.length;
                    }
                } else if (selectedGroup.type === 'series') {
                    // Fetch fresh series data from TMDB if new ID provided
                    let seriesData = null;
                    if (tmdbIdInput.value.trim()) {
                        showStatus('info', 'Fetching fresh data from TMDB...');
                        seriesData = await fetchTMDB(`/tv/${tmdbId}`);
                        if (seriesData) {
                            updatedInfo = true;
                        }
                    }
                    
                    // Process all episodes of the series
                    for (const item of selectedGroup.episodes) {
                        // Update episode info if fresh data was fetched
                        if (seriesData) {
                            // Update series-level info
                            const seriesCategory = currentData.Categories.find(c => c.MainCategory === "TV Series");
                            if (seriesCategory && seriesCategory.Entries[item.seriesIndex]) {
                                const series = seriesCategory.Entries[item.seriesIndex];
                                series.Title = seriesData.name;
                                series.Description = seriesData.overview || series.Description;
                                series.Poster = seriesData.poster_path ? `${TMDB_IMAGE_BASE}${seriesData.poster_path}` : series.Poster;
                                series.Thumbnail = seriesData.backdrop_path ? `${TMDB_IMAGE_BASE}${seriesData.backdrop_path}` : series.Thumbnail;
                                series.Rating = Math.round(seriesData.vote_average || series.Rating);
                                series.Year = parseInt(seriesData.first_air_date?.substring(0, 4) || series.Year);
                            }
                            
                            // Fetch individual episode data for episode-specific images
                            try {
                                const episodeData = await fetchTMDB(`/tv/${tmdbId}/season/${item.season}/episode/${item.episode}`);
                                if (episodeData) {
                                    // Update episode-specific info
                                    item.entry.Title = episodeData.name || item.entry.Title;
                                    item.entry.Description = episodeData.overview || item.entry.Description;
                                    item.entry.Thumbnail = episodeData.still_path ? `${TMDB_IMAGE_BASE}${episodeData.still_path}` : item.entry.Thumbnail;
                                    item.entry.Duration = formatDuration(episodeData.runtime) || item.entry.Duration;
                                }
                            } catch (error) {
                                console.log(`Could not fetch episode ${item.season}x${item.episode} data:`, error.message);
                            }
                        }
                        
                        // Generate embed sources for episode
                        const embedSources = generateEmbedSources(tmdbId, 'tv', item.season, item.episode);
                        
                        // Preserve existing servers and add embed sources
                        if (!item.entry.Servers) item.entry.Servers = [];
                        item.entry.Servers.push(...embedSources);
                        
                        // Update the actual data structure
                        const seriesCategory = currentData.Categories.find(c => c.MainCategory === "TV Series");
                        if (seriesCategory && seriesCategory.Entries[item.seriesIndex]) {
                            const series = seriesCategory.Entries[item.seriesIndex];
                            if (series.Seasons && series.Seasons[item.seasonIndex]) {
                                const season = series.Seasons[item.seasonIndex];
                                if (season.Episodes && season.Episodes[item.episodeIndex]) {
                                    season.Episodes[item.episodeIndex] = item.entry;
                                }
                            }
                        }
                        
                        processedItems++;
                        totalEmbedSourcesAdded += embedSources.length;
                    }
                }
                
                if (processedItems > 0) {
                    const infoMessage = updatedInfo ? 
                        `Updated info from TMDB and applied auto-embed to "${selectedGroup.title}" - processed ${processedItems} items, added ${totalEmbedSourcesAdded} embed sources` :
                        `Applied auto-embed to "${selectedGroup.title}" - processed ${processedItems} items, added ${totalEmbedSourcesAdded} embed sources`;
                    
                    showStatus('success', infoMessage);
                    saveData();
                    updateDataStats();
                    
                    // Clear the TMDB ID input
                    tmdbIdInput.value = '';
                    
                    // Refresh the checkboxes to remove the processed group
                    refreshContentCheckboxes();
                } else {
                    showStatus('error', 'No items were processed.');
                }
            } catch (error) {
                showStatus('error', `Error processing content: ${error.message}`);
            }
        }
    </script>
</body>
</html>